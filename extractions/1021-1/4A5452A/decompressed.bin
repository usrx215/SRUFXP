//-----------------------------------------------------------------------------
// envchangepopup.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var EnvironmentPopup = new Class({
	Extends:ModalControl,
	popuptype: '',
    initialize: function(){
    	this.parent("envchange");
	},
    show: function() {
		this.parent();
		var self = this,
            x;
		
		document.getElementById('envchangebtns').innerHTML = '';
		
		for(x = 0; x < application.Environments.length; x++){
			document.getElementById('envchangebtns').innerHTML += '<p>Select (' + x + ') for ' + application.Environments[x].name + '</p>';
		}

		application.events.subscribe(this, "back", this.handleBack.bind(this));
		
		setTimeout(function(){
			application.events.subscribe(self, "keydown", self.handleKeyPress.bind(self));
		}, 500);
	},
	unsubEvents: function(){
		application.events.unsubscribe(this, "back");
		application.events.unsubscribe(this, "keydown");
	},
	handleBack: function(payload){
		payload.preventDefault();
		this.unsubEvents();
		this.hide();
	},	
	setCurrentVal: function(env){
		application.CurrentEnvironment = env;		
		application.endPointServer = env + ".cinemanow.com";
		application.apiUrl = "https://" + env + ".cinemanow.com";
		
		log.write("Changing config (application.CurrentEnvironment): " + application.CurrentEnvironment);
		log.write("Changing config (application.endPointServer): " + application.endPointServer);
		log.write("Changing config (application.apiUrl): " + application.apiUrl);
		this.unsubEvents();
		this.hide();
		BrowseView.reset();
		
		configuration.writeValue("CustomEndPoint", env);
	},
	handleKeyPress: function(payload){
		switch(payload.args[0].event.keyCode){
			case application.keys.KEY_1:
				this.setCurrentVal(application.Environments[1].key);
				break;
			case application.keys.KEY_2:
				this.setCurrentVal(application.Environments[2].key);
				break;
			case application.keys.KEY_3:
				this.setCurrentVal(application.Environments[3].key);
				break;
			case application.keys.KEY_4:
				this.setCurrentVal(application.Environments[4].key);
				break;
			case application.keys.KEY_5:
				this.setCurrentVal(application.Environments[5].key);
				break;
			case application.keys.KEY_6:
				this.setCurrentVal(application.Environments[6].key);
				break;
			case application.keys.KEY_7:
				this.setCurrentVal(application.Environments[7].key);
				break;
			case application.keys.KEY_8:
				this.setCurrentVal(application.Environments[8].key);
				break;
			case application.keys.KEY_9:
				this.setCurrentVal(application.Environments[9].key);
				break;
			case application.keys.KEY_0:
				this.setCurrentVal(application.Environments[0].key);
				break;
			default:
				break;				 
		}
	}
});
//-----------------------------------------------------------------------------
// episodepanel.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author Lance_Wilson
 */
var EpisodePanelControl = new Class({
	id: 'episodepanel',
	title: null,
    initialize: function(){
    },
    show: function()
    {
        // Clear any previous titles that would show in the grid
        $('titlelist').innerHTML = "";

    	this.title = BrowseView.TitleViewControl.persist.title;
        this.title.show = $cn.utilities.ellipsis(this.title.show, 30);

		BrowseView.GridControl.loadHeader("episode_header.tpl", this.title);
		
		if(!this.TvSeasonsWheelControl) {
			this.TvSeasonsWheelControl = new TvSeasonsWheelControl(); 
		}

		this.TvSeasonsWheelControl.isLibrary = this.title.passID != null;
		this.TvSeasonsWheelControl.isSeasonal = this.title.seasonal;
		
		if (this.title.passID != null) {

			if (this.title.seasonal)	 {
			
				$cn.methods.getBundleListingPurchased(this.title.showTitleID,function(callback){
		        	log.write(callback.bundleItems.length);
		       
		        	this.TvSeasonsWheelControl.activate();
		        	this.TvSeasonsWheelControl.loadData(callback.bundleItems, this.title.seasonTitleID); 
					BrowseView.shrinkTitleDetails("episode-panel", null);
							
		        }.bind(this)); 
			}
			else {

	        	this.TvSeasonsWheelControl.activate();
	        	this.TvSeasonsWheelControl.loadData([{ titleID: this.title.showTitleID }]);
				BrowseView.shrinkTitleDetails("episode-panel", null);		
			}		
		}
		else {

			var className = this.title.seasonal ? 'episodegrid' : 'episodegrid-wide';
			application.events.publish('gridloading', {grid: 'titlegrid', message:"tvloading", className: className,  cssClass:"tv"});
			
			$cn.methods.getBundleListing(this.title.showTitleID,function(callback){
	        	log.write(callback.bundleItems.length);
	       
	        	application.currentView.layoutIsDirty = true;
	        	
	        	if(callback.bundleItems.length == 0){
                    log.write("##### ERROR - Empty bundle listing ######");
                    application.events.publish("error", {type: "system_error", "method": "getBundleListing" });
                    // Episodes button will not be shown instead of throwing error
	        		return;
	        	}

                BrowseView.shrinkTitleDetails("episode-panel", null);

                if (!this.title.seasonal) {
					$('titlegrid').show();
					BrowseView.LastGridProcess = "episodelist";
					application.events.publish('loadgrid', {
						grid: 'titlegrid',
						data: [],//callback.bundleItems,
						columns: 1,
						template: 'listgrid',
						gridProcess: 'episodelist',
						className: 'episodegrid-wide',
						returnFocus: application.element.current
					});
					
					navigation.setFocusElement($("titlelist").getElements("a")[0]);
				}
				else {
		        	this.TvSeasonsWheelControl.activate();
		        	this.TvSeasonsWheelControl.loadData(callback.bundleItems, this.title.seasonTitleID);
				}
	

				
	        }.bind(this)); 
		}
    },
    hide: function() {
    },
	onItemSelected: function(titleID) {
		
		if (this.TvSeasonsWheelControl.isLibrary) {
			$cn.methods.lookupPurchaseDetailsForTitle(titleID, function(result){
				application.events.publish('loadtitleview', {id: titleID, passID: parseInt(result.passID), type: 'library'});		
			});
		}
		else
			application.events.publish('loadtitleview', {id: titleID, checklibrary: true});		
	}
});
//-----------------------------------------------------------------------------
// giftcard.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author jessemccabe
 */
var GiftCardPanelControl = new Class({
	Extends:ModalControl,
	id: 'giftcard',
	layoutIsDirty: true,
	isValid: false,
	tpl: null,
	sku: '',
	keyboard: null,
	isPurchasePath: false,
    initialize: function(){
		log.write('giftcard.init()');
		this.parent('giftcard');
		
    },
    show: function(isPurchasePath, sku){
		$('ModalWindow').setAttribute('style', '');
    	var headingTxt = (isPurchasePath) ? application.resource.gift_card_poup_heading_purchase_path : application.resource.gift_card_poup_heading;
    	
    	this.parent();
    	this.loadData([{buttonTxt:'Cancel', headingTxt: headingTxt}]);
    	BrowseView.GiftCardKeyboard.show();
    	this.sku = (isPurchasePath) ? sku : 0;
    	this.isValid = false;
		this.isPurchasePath = isPurchasePath;
    	application.events.subscribe(this, "back", this.handleBack.bind(this));
    	application.events.subscribe(this, "navigate", this.handleNavigate.bind(this));
    },
    hide: function(){
    	this.isValid = false;
    	this.parent();
    	application.events.unsubscribe(this, "back");
    	application.events.unsubscribe(this, "navigate");
    },
    apply: function(){
    	if(this.isValid) {
    		$cn.data.CurrentPromotion = this.keyboard.value.trim();
    	}
    },
    handleBack: function(payload){
    	payload.preventDefault();
    	application.currentView.GiftCardKeyboard.hide();
    	this.hide();
    },
    handleNavigate: function(payload){
    	if(payload.args[0].direction == "right" && 
    		(	application.element.current == ""
    			
    		)
    	){
	
		}
    },
    redeem:function(){
    	$('giftcodeerror').innerHTML = '';
    	var self = this,
			timer = null;
    	this.isValid = false;
    	this.isProcessing = true;
		
		var code = this.keyboard.value.trim();
		if (!code.length) {
			this.isProcessing = false;
			$('giftcodeerror').innerHTML = 'Invalid code.';
			return;
		}    	
    	
		if (this.isPurchasePath) {			
			timer = $cn.utilities.showLoadingModal(2000, "Redeem Gift Code...");
			$cn.methods.verifyCode(this.sku, code, function(api){
				$cn.utilities.clearLoadingSpinner(timer);
				self.isProcessing = false;
                if($('giftcodeerror')==null) //in case we are coming back from activation
                {
                    BrowseView.GiftCardPanel.show(true, self.sku);
                    navigation.setFocus("gcredeem");
                }
				if (api.responseCode == 0) {
					/* Successfully applied coupon, update UI */
					self.isValid = true;
					self.keyboard.clear();
					
					if (api.discountType == "GiftCertificate") {
						/* This is a Gift Code */
						$('giftcodetotal').innerHTML = '-' + application.resource.currency_symbol + $cn.utilities.formatAsMoney(api.giftCertificateBalance);
						$('giftcodesredeemed').show();

						application.events.publish("redeemed", { giftCertificate: api.giftCertificateBalance });
					}
					else {
						if (api.discountType == "Coupon") {
							$('coupontotal').innerHTML = '-' + application.resource.currency_symbol + $cn.utilities.formatAsMoney(api.discountAmount);
							$('couponseredeemed').show();

							application.events.publish("redeemed", { coupon: code, amount: api.discountAmount });
						}
					}
				}
				else {
					var errorMsg = 'Invalid code.';
					
					/* Error with the coupon code or scenario. Display Reason. */
					switch (api.responseCode) {
						case 36:
							errorMsg = 'Coupon code already used.';
							break;
						case 37:
							errorMsg = 'Code already used.';
							break;
						default:
							break;
					}
					
					self.keyboard.clear();
					$('giftcodeerror').innerHTML = errorMsg;
				}
				
			});
		}
		else{
			timer = $cn.utilities.showLoadingModal(2000, "Redeem Gift Code...");
			$cn.methods.applyGiftCode(code, function(api){
				$cn.utilities.clearLoadingSpinner(timer);
				self.isProcessing = false;
				
				if($('giftcodeerror')==null) //in case we are coming back from activation
                {
                    BrowseView.GiftCardPanel.show(false);
                    navigation.setFocus("gcredeem");
                }
				if (api.responseCode == 0) {
					/* Successfully applied coupon, update UI */
					self.isValid = true;
					self.keyboard.clear();
					
					$('giftcodetotal').innerHTML = '-' + application.resource.currency_symbol + $cn.utilities.formatAsMoney(api.giftCertificateBalance);
					$('giftcodesredeemed').show();					
				}
				else {
					var errorMsg = 'Invalid code.';
					
					/* Error with the coupon code or scenario. Display Reason. */
					switch (api.responseCode) {
						case 36:
							errorMsg = 'Code already used.';
							break;
						case 37:
							errorMsg = 'Code already used.';
							break;
						default:
							break;
					}
					
					self.keyboard.clear();
					$('giftcodeerror').innerHTML = errorMsg;
				}
			});
		}
    }
});
//-----------------------------------------------------------------------------
// gridcardkeyboard.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var GiftCardKeyboardControl = new Class({
	Extends: KeyboardControl,
	id: 'giftcardkeyboardcontrol',
	_currentCategory: '',
	_refined: false,
	_hault: 0,
	value: '',
	initialize: function(){
		this.parent();
	},
	keyboardFocus: function(payload) {
		if(document.getElementById(payload.args[0].focusedelem)){
			if($('skinnykeyboard').isParentOf($(payload.args[0].focusedelem))){
				log.write('skinnykeyboardfocus');
				if(this._refined)
				{
					this.handlechange();
				}
			}
		}
	},
	unsubEvents: function(){
		application.events.unsubscribe(this, "back");
		application.events.unsubscribe(this, "keydown");
	},
	handleKeyPress: function(payload){
		switch(payload.args[0].event.keyCode){
			case application.keys.KEY_1:
				application.navigator.setFocus('Skinny1');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '1'});
				break;
			case application.keys.KEY_2:
				application.navigator.setFocus('Skinny2');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '2'});
				break;
			case application.keys.KEY_3:
				application.navigator.setFocus('Skinny3');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '3'});
				break;
			case application.keys.KEY_4:
				application.navigator.setFocus('Skinny4');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '4'});
				break;
			case application.keys.KEY_5:
				application.navigator.setFocus('Skinny5');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '5'});
				break;
			case application.keys.KEY_6:
				application.navigator.setFocus('Skinny6');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '6'});
				break;
			case application.keys.KEY_7:
				application.navigator.setFocus('Skinny7');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '7'});
				break;
			case application.keys.KEY_8:
				application.navigator.setFocus('Skinny8');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '8'});
				break;
			case application.keys.KEY_9:
				application.navigator.setFocus('Skinny9');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '9'});
				break;
			case application.keys.KEY_0:
				application.navigator.setFocus('Skinny0');
				application.events.publish('keyboardselect', {caller: 'giftcardkeyboardcontrol', value: '0'});
				break;
			default:
				break;				 
		}
	},
	valuechange: function(payload) {
		if(payload && payload.args[0].caller == this.id) {
			
			if(this._currentValue == "")
				this.shiftReset();
			
			$('SkinnySearchText').set('html', this._currentValue + '_');
			
			this.shiftLeft();
			
			this.handlechange();
		}
	},
	shiftLeft: function()
	{
	
		var textWidth = parseInt($('SkinnySearchText').clientWidth);
		var wrapWidth = parseInt($('SkinnySearchTextWrap').clientWidth)-15;
	    var left = $('SkinnySearchText').getStyle("margin-left");
	    
	    if(textWidth > wrapWidth)
		{
		    if (left == "")
		        left = 0;
		    
		    var effect = new Fx.Morph($('SkinnySearchText'), {
				duration: 300, 
				transition: Fx.Transitions.Sine.easeOut
			});
		    effect.start({'margin-left': wrapWidth - textWidth+"px"});
	    }else {
	    	this.shiftReset();
	    }
	},
	shiftReset: function()
	{
		$('SkinnySearchText').setStyle('margin-left', '0');
	},
	keyselect: function(payload) {
		if(!BrowseView.GiftCardPanel.isProcessing) {
			log.write('keyboard select:' + payload.args[0].value);
			log.write(payload);
			this._currentValue +=  payload.args[0].value;
			this.valuechange(payload);
		}
	},
	clear: function(){
		$('SkinnySearchText').set('html', '_');
		this.value = '';
    	this.shiftReset();
		this._currentValue = '';
	},
	handlechange: function() {
		/* We do not need to do anything here. All functions get called from a button. */
		this.value = this._currentValue;
	},
	setcategory: function(payload)
	{
		this._currentCategory = payload.args[0].selectedvalue;
		this.keyclear();
		this.handlechange();
	},
	show: function (){
		this._currentValue = '';
		$('SkinnySearchText').set('html', '_');
		document.getElementById('skinnykeyboard').className = this.id;
		
		log.write($$("a.standard").each(function(item){item.show()}));
		$("skinnykeyboard").show();
		
        navigation.buildNavigation($('skinnykeyboard').getElements('a'));
        application.events.subscribe(this, "back", this.handleBack.bind(this));
		application.events.subscribe(this, "keydown", this.handleKeyPress.bind(this));		
	},
	handleBack: function(payload){
		payload.preventDefault();
		this.unsubEvents();
		this.hide();
	},	
	hide: function()
	{
		document.getElementById('keyboard').className = '';
		this.unsubEvents();
		$("skinnykeyboard").hide();
	}
});
//-----------------------------------------------------------------------------
// grid.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author tjmchattie
 */
var GridControlProperties = {
		DEBUG: false,
		id: 'titlegrid',
		persist: {},
	    controls:{},
	    history: [],
	    layoutIsDirty: true,
	    template: '',
	    tpl: null,
		tplCache: {},
	    scroll: true,
	    tplMeta: null,
	 //   tplMetaCast: null,
	    altMessage: null,
	    itemidx: -1,
		isActive: false,
	    hault: 0,
	    currentId: 0,
	    currentTopLeft: 0,
	    totalRecords: 0,
	    currentPage: 0,
	    genreid: 0,
        totalPages: 0,
		rowHeight: 0,
	    gridLoaded: false,
	    itemsRequested: false,
		metaRequest: null,
	    spinnerPos: 1,
	    spinnerTimer: null,
	    spinnerSpinning: false,
	    lastMovement: new Date(),
	    lastNavigationDirection: '',
	    spinnerPosition: 1,
	    imgPreloader: [],
        prefetchSpinner: false,
	    config: {
	    	numRows: 3,
	    	numCols: 3,
	    	numDisplay: 9,
	    	numStartIndex: 0
	    },
	    
	    _data: [],
	    initialize: function(params){
	    	if(params && params.id)
	    	{
	    		this.id = params.id;
	    	}
            
	    	/* Setup the known templates to be ready for rendering. */

	    		//this.tplContainer = "listgrid";
			this.loadTemplate("listgrid.tpl");
			this.loadTemplate("refinementgrid.tpl");
			this.loadTemplate("librarylist.tpl");
			this.loadTemplate("titlelist.tpl");
			this.loadTemplate("similarlist.tpl");


			
			log.write('gridcontrol.init()');		
			
			/* Wheel item is registered here because the data source is changed when the wheel item is changed. 
			 * This might be good to be in the store.js file? Possibly seperate the control functionality and specific view functionality? */
			//application.events.subscribe(this, 'wheelitemchanged',this.handleWheelItemChange);
			
			/* These events handle the display of meta data when an element in the grid has focus. */
			application.element.registerControl(this);
			
			application.events.subscribe(this, 'elementfocus', this.gridFocus.bind(this));
			application.events.subscribe(this, 'elementblur', this.gridBlur.bind(this));
		    application.events.subscribe(this, 'griditemselected', this.loadMeta.bind(this));
	        application.events.subscribe(this, "navigate", this.navigate.bind(this));
	        application.events.subscribe(this, 'wheelvaluechanged',this.handleWheelItemChange.bind(this));
	        //application.events.subscribe(this, 'wheelitemchangedinit',this.handleWheelItemChangeInit.bind(this));        
	        application.events.subscribe(this, 'viewchanged', this.onViewChange.bind(this));
			application.events.subscribe(this, 'savestate', this.onSaveState.bind(this));
			application.events.subscribe(this, 'restorestate', this.onRestoreState.bind(this));
    		application.events.subscribe(this, 'error', this.onHandleError.bind(this));

			application.events.subscribe(this, 'scroll', function(payload){
				if ($('titlelist').offsetWidth) {
					this.movegrid(payload.args[0].direction, this.config.numRows);				
				}
			}.bind(this));
	    },
	    init: function() { },
		cleanUI: function(){
	    	if($('titlelist').getChildren().length > 0){
				$('titlelist').getChildren().destroy();
			}

//			$("titlegrid_container").removeClass("refinementgrid");
			document.getElementById('titlelist').className = '';
			
			if (this.tplMeta) {
				this.tplMeta.empty();
				this.tplMeta = null;		
			}
			
//			this.tplMetaCast.empty();
			BrowseView.ScrollBar.deactivate();
		},
		handleWheelItemChangeInit: function(payload){
			log.write("WheelItemChangedInit Called.");
			
			var wheelid = payload.args[0].wheelinstance;
			
			if(wheelid != "SearchWheelControl" && wheelid != "SettingsWheelControl" && wheelid != "TitleCheckOutWheelControl" && wheelid != "TvSeasonsWheelControl" && wheelid != "HelpWheelControl") {
				var columns = 3;
				
				if(payload.context.activeControl == "TitleMetaWheelControl")
				{
					columns = 2;
				}

				if(payload.args[0].slavevalue != payload.context.currentId) {
					application.events.publish('gridloading', {grid: 'titlegrid', message: "loading", columns: columns});
				}
			}
		},
		/*
		 * When the wheel item is changed the grid should update itself with fresh data. 
		 */
		handleWheelItemChange: function(payload){
			log.write("grid.handleWheelItemChange Debug: Enter with payload:")
			log.write(payload);
			var self = this,
                wheelid = payload.args[0].wheelinstance,
                slaveValue = payload.args[0].slavevalue,
                columns;
			
			if(wheelid != "SearchWheelControl" && wheelid != "SettingsWheelControl" && wheelid != "TitleCheckOutWheelControl" && wheelid != "TvSeasonsWheelControl" && wheelid != "HelpWheelControl") {
				columns = 3;
			
				if(payload.context.activeControl == "TitleMetaWheelControl")
				{
					columns = 2;
				}

				if(slaveValue != payload.context.currentId) {
					payload.context.currentId = slaveValue;
					if (this.DEBUG) log.write("grid.WheelItemChanged Debug: About to call publish with gridloading");
					application.events.publish('gridloading', {grid: 'titlegrid', message: "loading", columns: columns});
					
					//Timeout was implemented to let the slave wheel have some time to finish animating and potentially make a different selection.
					setTimeout(function(){
						//Verify if the current wheel value matches the current payload. This is needed because of the set timeout
						if(BrowseView.CurrentWheelValue.indexOf(String(slaveValue)) > -1) {
							if (this.DEBUG) log.write("grid.WheelItemChanged Debug: About to call getTitlesByGenreId.");
							$cn.methods.getTitlesByGenreId(slaveValue, 1, function(callback){
								if (this.DEBUG) log.write("grid.WheelItemChanged Debug: Back from getTitlesByGenreId with callback " + callback);
								//Verify if the current wheel value matches the current payload. This is needed because of the async call						
								if(BrowseView.CurrentWheelValue.indexOf(String(slaveValue)) > -1) {
									var altMessage = null;
									if ($cn.data.RecomendedGenreIds && $cn.data.RecomendedGenreIds.contains(callback.data.result.genreID.toString())) {
										altMessage = "recommended_empty"
									}	
									BrowseView.LastGridProcess = "titlelist";								
									if (this.DEBUG) log.write("grid.WheelItemChanged Debug: About to call publish with loadGrid");
									application.events.publish('loadgrid', {grid: 'titlegrid', data: callback.data.result.items, genreid: callback.data.result.genreID.toString(), customLength: callback.data.result.totalItems, customPages: callback.data.result.totalPages ,  columns: columns, altMessage: altMessage, gridProcess: 'titlelist', cssClass: ''});
								}
								else {
									if (this.DEBUG) log.write("[CALLBACK] Current wheel value does not match payload. Ignore request.");
								}
						    });
						}
					}, 1000);  //Requests will be made 1 second after receiving the event
				}		 
			}
		},
		/*
		 * Callback that is responsible for adding the "hover" class to the title list when the current element
		 * has focus of an element in the titlelist. The idea is to display the gradient overlay when a box art is
		 * selected.
		 */
		gridFocus: function(payload){
			if(document.getElementById(payload.args[0].focusedelem)){
				if($('titlelist').isParentOf($(payload.args[0].focusedelem))){
					log.write('gridfocus');
					$('titlemeta').setStyle("visibility", "visible");
					this.itemidx = parseInt($(application.element.current).get('titleidx'));
					this.isActive = true;
				} else {

					$('titlemeta').setStyle("visibility", "hidden");
					$('titlemeta').setStyle("top", "");
					$('titlelist').setStyle("height", "470px");
					if($('titlegrid').hasClass("episodegrid")) {
						$('titlelist').setStyle("height", "352px");
					}
					this.itemidx = -1;
					this.isActive = false;
				}
			}
		},
		gridBlur: function(){
			
		},
		/*
		 * Load data will:
		 * 1) Set the data source for the grid view
		 * 2) Render the local controls
		 * 3) set the data for the first item.  
		 */
		loadData: function(titles, columns, template, position, totalRecords, totalPages,genreid) {
            this.numColumns = columns;
			this.cleanUI();
			this.currentPage = 1;
			this.totalRecords = totalRecords;
			this.totalPages = totalPages;
			this.genreid = genreid;
			this.itemsRequested = false;
			this.template = (template) ? template : "titlelist";
			this.tpl = this.loadTemplate(this.template + ".tpl");
			switch(this.template)
			{
				case "refinementgrid":
				case "listgrid":
					$("titlelist").addClass("listgrid");
					break;
				case "librarylist":
				case "similarlist":
				default:
					$("titlelist").removeClass("listgrid");
					break;
			}
			
			this.config.numStartIndex = position == null ? 0 : position;
			this.config.numCols = typeof(columns) != 'undefined' ? columns : 3;
//			this.resize(this.config.numCols);
			
			this.hideAltMessage();
			
			this._data = [];
			
			if(titles)
			{
				this._data = titles;
			}
			this.draw();
			
			application.events.publish('gridloaded', {grid: this.id});
			
		},
		loadMeta: function(payload){
			var timeout = (this.lastNavigationDirection == "up" || this.lastNavigationDirection == "down") ? 250 : 1;

			var metakey = payload.args[0].id;
			this.lastMetakey = payload.args[0].id;

			log.write(this.lastMetakey +":"+metakey);

			setTimeout(function(){
                var y,
                    z;

				if(metakey == this.lastMetakey) {
					/* If the current view is still relevant then continue */
					if(payload.context.id == "titlegrid") {
						
						this.tplMeta = this.loadTemplate("titlelist." + payload.args[0].type + "meta", "titlemetacontainer");

						$("titlemetacontainer").erase('class');
						$("titlemetacontainer").addClass(payload.args[0].type + "meta");
		
						if(payload.args[0].type == 'cast')
						{
							log.write("Cast Bio: loading id: " + payload.args[0].id);
							this.tplMeta.emptyAndAppend({});
							
							$cn.methods.getCastBio(payload.args[0].id, function(callback){
								
								if(metakey == this.lastMetakey) {
									callback.bio = (callback.bio) ? callback.bio.firstWithEllips(150) : '';									
									this.tplMeta.emptyAndAppend(callback);
									this.tplMeta.apply();
		
									$('castmeta').setStyle('visibility', 'inherit');
								}
								
							}.bind(this));
						}
						else if(payload.args[0].type == "episode") {
							//Set titlelist height according to the number of episode
							var episodeCount = this.totalRecords;
							// +1 is for Season Details row
							var episodeCountHeight = (episodeCount + 1) * 32;
							if(episodeCount < 10) {
								$('titlelist').setStyle("height", episodeCountHeight + "px");
								$('titlemeta').setStyle("top", (episodeCountHeight + 34) + "px");
							} else {
								$('titlelist').setStyle("height", "352px");
								$('titlemeta').setStyle("top", "386px");
							}
							title = $cn.data.TitleSummaryCache[payload.args[0].id];
							this.loadTitleSummary(title, payload, payload.args[0].passID);
						}
						else if(payload.args[0].type == 'similar' && $cn.data.TitlesBySimilar[BrowseView.RecomendationWheelControl.titleID + "-" + BrowseView.RecomendationWheelControl.slaveIdx + "-1"])
						{
							var results = $cn.data.TitlesBySimilar[BrowseView.RecomendationWheelControl.titleID + "-" + BrowseView.RecomendationWheelControl.slaveIdx + "-1"].data.result,
							title = $cn.data.TitleSummaryCache[payload.args[0].id];
							this.loadTitleSummary(title, payload.args[0], undefined);
							
	                        // Find why similar
                            for(x = 0; x < results.similarTitles.length; x++){
                                if(payload.args[0].id == results.similarTitles[x].keyName){
                                    title.synopsys = "Similar because: " + results.similarTitles[x].keyValue;
                                    break;
                                }
                            }
						}
						else
						{
							title = $cn.data.TitleSummaryCache[payload.args[0].id];
							
							if(!title){
							    if(payload.args[0].type == "library"){
									$cn.methods.getPurchasedTitle(payload.args[0].passID, payload.args[0].id, function(result) {
							        	if(result){
								        	if(result.responseCode == 0){
												this.updateTitleSummary(metakey, this.lastMetakey, result, payload);
											}
											else{
												this.updateTitleSummary(metakey, this.lastMetakey, null, payload);
												result.errorHandled = true;
											}
							        	}
							        }.bind(this));
							   }
							   else{
									$cn.methods.getShortSummary(payload.args[0].id, function(result) {
							        	if(result){
								        	if(result.responseCode == 0){
												this.updateTitleSummary(metakey, this.lastMetakey, result, payload);
											}
											else{
												this.updateTitleSummary(metakey, this.lastMetakey, null, payload);
												result.errorHandled = true;
											}
							        	}
							        }.bind(this));
							   }
							}
							else
							{	 
							    // Before setting HTML to an element make sure that the element is still present and also check that the current title is selected.
							    if(metakey == this.lastMetakey) {
							        log.write("grid: Else processing, about to call loadTitleSummary on title " + title);
								    this.loadTitleSummary(title, payload, payload.args[0].passID);
							        log.write("grid: Else processing, back from loadTitleSummary on title " + title);
							    }
							}
						}
					}
				}
			}.bind(this),timeout);
		},
		updateTitleSummary: function(metakey, lastMetakey, result, payload){
			if(metakey == lastMetakey){
				this.loadTitleSummary(result, payload, payload.args[0].passID);
				if(result){
					$cn.data.TitleSummaryCache[payload.args[0].id] = result;
				}
			}
			
		},
		loadTitleSummary: function(title, payload, passID){
		    log.write('grid.loadTitleSummary: Entered with title ' + title);
		    
		    //When the title is not exist in store, should hide summary
		    if (!title)	{
				$('titlemetacontainer').getElement('.metapanel').setStyle('display', 'none');
				return;
		    }   
		    
			var name = title.name;
			var episode = '',
			//This function was taken out of the template and added here since it applied to all short summaries.
			    synopsys = $cn.utilities.highlightKeywordForSynopsis(title.synopsys, BrowseView.SearchKeyboard.getkeyword()),
                hasUv;
            if(BrowseView.currentState === "library-view"){
                if ($cn.data.isPassUVCache && $cn.data.isPassUVCache[passID]) {
                    hasUv = $cn.data.isPassUVCache[passID].isPassUV;
                } else {
                    hasUv = false;
                }
            } else {
                hasUv = $cn.utilities.getMeta("HasUV", title.metaValues);
            }

            hasUv = $cn.utilities.isTrue(hasUv) && $cn.config.EnableUV;

            log.write("hasUv is: " + hasUv + " from " + BrowseView.currentState);
			
			if (title.titleType == "TV_Episode" && payload.args[0].type != 'episode') {
				name = $cn.utilities.getMeta("TVSeasonHeader", title.metaValues);
				episode = $cn.utilities.getMeta("TVEpisodeHeader", title.metaValues);
				
				//[Remove in library as well] if (payload.args[0].type == 'title')
				synopsys = '';
			}
			else if (title.titleType == "TV_Season") {
				name = $cn.utilities.getMeta("TVSeasonHeader", title.metaValues);
			}

			if(this.tplMeta) {
				this.tplMeta.emptyAndAppend({
					titleID: title.titleID,
					name: name,
					mPAARating: title.mPAARating,
                    UVAvailable: (hasUv ? "yesUV" : "noUV"),
					Episode: episode,
					synopsys: synopsys
				});
				
				var titleElem = $('titlemeta_title');
				
				
				if(titleElem) {
					
					var maxWidth = titleElem.getParent().getSize().x;
					if(titleElem.getNext()) {
						maxWidth = maxWidth - (titleElem.getNext().offsetWidth) - 11;
                        if(titleElem.getNext().getNext()){
                            maxWidth = maxWidth - (titleElem.getNext().getNext().offsetWidth);
                        }
					}
					//log.write('Title Width: ' + titleElem.getDimensions().width);
					titleElem.setStyle('width', Math.min(titleElem.offsetWidth, maxWidth) + 2);
					
					if(titleElem.getNext()) {
						titleElem.getNext().setStyle('padding-left', '3px');
					}
					//log.write('Title Parent Width: ' + titleElem.getParent().getDimensions().width);
					//log.write('Max Width: ' + maxWidth);
					//log.write('Final Width: ' + titleElem.getStyle('width'));
				}
				
				this.tplMeta.apply();
				$('titlemetacontainer').getElement('.metapanel').setStyle('visibility', 'inherit');
				
				log.debug("Title: " + name + ", mPAARating: " + title.mPAARating);
	        	log.debug("############################");
			}
		},
		loadHeader: function(template, data) {

			application.putInnerHTML($('titlegrid_header'), "");
			var tpl = new ui.template("titlegrid_header", application.ui.loadTpl(template));

			tpl.compile();
			tpl.append(data);
			tpl.apply();
			
			$('titlegrid_container').addClass("header");
			
		},
		getElipsisLength: function() {
			
			if (BrowseView.DockControl.selection == 'dock-search') {
				return 95;
			}
			else if(this.config.numCols == 2) {
				return 65;
			}
			else {
				return 95;
			}
		},
		loadTemplate: function(template, container) {
			
			var tpl = this.tplCache[template];
			
			if (tpl == null) {
				if (container == null)
					container = "titlelist";
					
	    		tpl = new ui.template(container, application.ui.loadTpl(template));
	    		tpl.compile();
				this.tplCache[template] = tpl;
			}
			
			return tpl;
		},
		configure: function(){
			var container = $('titlelist'),
                containerHeight;

			if(container != null)
			{
	/*			if(this.template == "listgrid")
				{
					titleWidth = 235;
					this.rowHeight = 25;		// TODO: Get from element
				}*/
				if (this._data && this._data.length)
				{
					container.show();
					var index = this.config.numStartIndex;
					
					if(this._data[index]){
						this._data[index].titleidx = index;
						this.tpl.append(this._data[index]);
					
						// TODO: add margins
						var item = container.getFirst();
						this.configure.titleWidth = item.offsetWidth;
						this.rowHeight = item.offsetHeight + parseInt(item.getStyle('margin-top')) + parseInt(item.getStyle('margin-bottom'));
					}
				}
				else {
//					titleWidth = 130;
					this.rowHeight = 150;
				}

//				containerWidth = container.clientWidth > 0 ? container.clientWidth : this.config.numCols * titleWidth;
				containerHeight= container.clientHeight > 0 ? container.clientHeight : this.config.numRows * this.rowHeight;

//				this.config.numCols = Math.floor(containerWidth / titleWidth);
				this.config.numRows = Math.floor(containerHeight / this.rowHeight);
				this.config.numDisplay = this.config.numCols * this.config.numRows;
			}
		},
		/* Read config values and render grid */
		resize: function(columns) {
			if(this.template == "listgrid")
			{
				// TODO: Widths need to be style based
				log.write("Singlewheel display: " + $('singlewheel').getStyle("display"));
			}

			$("titlemeta").setStyle("width", $('titlelist').offsetWidth);
		},
		redraw: function(titles){
			
			var items = $('titlelist').getChildren();
	    	if(items.length > 0){
				items.destroy();
			}
			
			var maxStartIndex = Math.floor((titles.length - this.config.numCols) / this.config.numCols) * this.config.numCols;
			var titleId = this.itemidx >= 0 ? this._data[this.itemidx].titleID : 0;
			 
			if (this.config.numStartIndex > maxStartIndex) {
				this.config.numStartIndex = maxStartIndex;
			}
			
			this._data = titles;
			this.resize();
			this.draw();
			
			var selection = $('titlelist').getElement("a[titleid='" + titleId + "']");
			
			if (selection)
				navigation.setFocusElement(selection);
				
			application.events.publish('gridloaded', {grid: this.id});
		},
		draw: function(){
//			this.cleanUI();
	/*		switch(this.template)
			{
				case "refinementgrid":
					$("titlelist").addClass("listgrid");
					break;
				case "listgrid":
					$("titlelist").addClass("listgrid");
					break;
				default:
					$("titlelist").removeClass("listgrid");
					break;
			}*/
			
			/*
			 *  1) Create elements for titles
			 *  2) Attach a focus
			 */
			var x,
                endCount;
			//get width of parent and reset numCols
			$('titlegrid').show();
			this.configure();
			this.resize(this.config.numCols);
			
			endCount = Math.min(this.totalRecords, this.config.numStartIndex + this.config.numDisplay);
			var self = this;

			if(this.totalRecords > 0)
			{
				
			
				this.scroll = !(this.totalRecords < this.config.numDisplay);
//				BrowseView.ScrollBar.activate(this);
				log.write("totalRecords: " + this.totalRecords + " numDisplay: " + this.config.numDisplay + " numCols: " + this.config.numCols + " this.scroll: " + this.scroll);
				
				
				for(x = this.config.numStartIndex + 1; x < endCount; x++){		
					
					if(this._data[x]){
						var tmpImgArr = [], imgPreloaderIdx=0;
						this._data[x].titleidx = x;
						this.tpl.append(this._data[x]);
						
						//Preload next image
						if(this._data[x + 9]) {
							tmpImgArr[imgPreloaderIdx] = new Image();
							tmpImgArr[imgPreloaderIdx].src = "http://cache.cinemanow.com/images/boxart/v2_107/" + this._data[x + 9].boxartPrefix + "v2_107.jpg";
							imgPreloaderIdx++;
						}
						
						tmpImgArr = null;
						delete tmpImgArr;
						
						/* If title is not on the global title list then add it */
						if(!$cn.data.TitleCache[this._data[x].titleID]) {
							$cn.data.TitleCache[this._data[x].titleID] = this._data[x];
						}
					}
				}

				this.tpl.apply();
                $$('#titlelist .title img').each(function(item){
                    item.onerror = function(e){
                        log.write("IMAGE ERROR");
                        item.hide();
                    }
                });

                //Custom default image function for themes that want more than 1 default image
                if (typeof $cn.config.CustomDefaultGridImage == 'function') {
                    $$('#titlelist .title .title-text').each(function(item) {
                        var className = $cn.config.CustomDefaultGridImage(item);
                        item.addClass(className);
                    });
                }

                var titlelist = $('titlelist');
				var item = titlelist.getFirst();
//				var rowSize = item.getSize().y + parseInt(item.getStyle('margin-top')) + parseInt(item.getStyle('margin-bottom'));
				var visibleRows = Math.min(Math.floor(($('titlemeta').getPosition().y - titlelist.getPosition().y) / this.rowHeight), this.config.numRows);
				var rows = Math.ceil(this.totalRecords / this.config.numCols);
				var isEpisodes = $('store').hasClass('episode-panel');

				if(isEpisodes) {
                    log.write("##### adjusting tv episodes scrollbar ########");
					$('scrollbar').setStyles({ 'margin-top': '33px', 'height': titlelist.offsetHeight });
					$('scrollbar').getElement('.scrollarea').setStyle('height', 320);
				} else {
				// TODO: Move scrollbar into grid container
				$('scrollbar').setStyles({ 'height': titlelist.offsetHeight });
				$('scrollbar').getElement('.scrollarea').setStyle('height', 419);
				}
				//Added to only draw the scroll bar in the event that there is one visible page or more
				if(Math.max(0, rows - visibleRows) > 0) {
					BrowseView.ScrollBar.setPosition(Math.floor(this.config.numStartIndex / this.config.numCols));
					BrowseView.ScrollBar.setRange(Math.max(0, rows - visibleRows));
					BrowseView.ScrollBar.draw();
				}
				
			}
			else { //NO RESULTS MESSAGE
				this.showAltMessage();
			}

			application.currentView.layoutIsDirty = true; 
		},
		itemCount: function() {
			return this.totalRecords;
		},
		getPosition: function() {
			return BrowseView.ScrollBar.getPosition() * this.config.numCols;
		},
		remove: function(index) {
			
	/*		if (index >= 0 && index < this._data.length) {
				var list = $('titlelist');
				
				this._data.splice(index, 1);
				this.config.numStartIndex = parseInt(list.getFirst().getElement('a').get('titleidx'));
				this.draw();
				
				var nextIndex = Math.min(this._data.length - 1, this.itemidx);
				navigation.setFocusElement(list.getElement("a[titleidx='" + nextIndex + "']"));
			}*/
			
//				if (this.conig.numStartIndex / this.config.numCols)

		
			if (index >= 0 && index < this.totalRecords) {
				var list = $('titlelist'),
				    items = list.getChildren(),
                    x;
				
				this._data.splice(index, 1);
				
				if (items.length) {
					
					var firstIndex = parseInt(items[0].getElement('a').get('titleidx')),
						nextIndex = firstIndex + items.length;
					
					if (index >= firstIndex && index < nextIndex) {
						
						this.tpl.empty();
						for(x = firstIndex; x < nextIndex; x++){
							if(this._data[x]) {
								this._data[x].titleidx = x;
								this.tpl.append(this._data[x]);
							}	
							
						}
						this.tpl.apply();
						
						if (index == this.itemidx) {
							var itemidx = Math.min(this.totalRecords - 2, index);
							navigation.setFocusElement(list.getElement("a[titleidx='" + itemidx + "']"));
						}
						
						this.totalRecords--;
					}
				}

				// Update the scrollbar
				var pos = BrowseView.ScrollBar.getPosition();
				BrowseView.ScrollBar.setRange(this.totalRecords < (this.config.numDisplay - this.config.numCols) ? 0 : 
					Math.ceil((this.totalRecords - (this.config.numDisplay - this.config.numCols)) / this.config.numCols));
				
				if (pos > 0 && pos > BrowseView.ScrollBar.range)
					this.movegrid("up", 1);
			
				//Reset navigation
				application.currentView.layoutIsDirty = true; 
			}
		},
		showAltMessage: function(){
			var template = ''; 
			if (this.altMessage) {
				template = this.altMessage;
			} else {
				if (BrowseView.DockControl.selection == 'dock-search') {
					if (BrowseView.SearchKeyboard._currentValue.length >= 1)
						template = "search_empty";
					else
						return;
				} else
					template = "empty";
			}
			
			var tpl = new ui.template("altmessage", application.ui.loadTpl(template + ".tpl"));
			tpl.compile();

			tpl.empty();
			tpl.append();
			tpl.apply();
			
			$('titlelist').hide();
			$('altmessage').show();
		},
		hideAltMessage: function() {
			$('altmessage').hide();
			$('altmessage').set('html', '');
			
		},
		onViewChange: function(payload){
			this.currentView = payload.args[0];
		},
		loadPage: function(page) {
			$cn.methods.getTitlesByGenreId(this.genreid, page, function(callback){
			    self = this.self;
			    log.write('Got title response. itemsRequested=' + self.itemsRequested + ', page=' + this.page + ', currentPage=' + self.currentPage);
			    if (self.itemsRequested && self.currentPage == this.page) {
				    self.itemsRequested = false;
				    log.write('before concat: ' + self._data.length + ' result items. ->' + callback.data.result.items.length);
				    self._data = self._data.concat(callback.data.result.items);
				    log.write('after concat ' + callback.data.result.items.length + ' items, yielding ' + self._data.length);
					
				    // At one time we were setting $cn.data TitlesByGenre here by doing this  
				    //   $cn.data.TitlesByGenre[this.genreid].data.result.items = 
				    //      $cn.data.TitlesByGenre[this.genreid].data.result.items.concat(callback.data.result.items);
				    //   $cn.data.TitlesByGenrePages[this.genreid + "-" + this.currentPage] = true;
				    // But all setting of TitlesByGenre[] and TitlesByGenrePages[] are done in 
				    // the callback inside getTitlesByGenreId after it issues WS GetBrowseList.
					
                    if (self.prefetchSpinner) {
                        self.movegrid("down", 0);
                        application.events.publish('gridloaded', {grid: self.id});
                    }
                 }
		    }.bind({self:this, page:page}));
		},
		movegrid: function(direction, rows){
			log.write("hault: " + this.hault);
			// JS Hoisting: http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting	
			// good to put vars at top of function so that there is no "stealth" shadowing of globals through hoisting.
			var animation = application.loadAnimation("grid"),
				animationDuration = animation.options.duration,
				cleanupFocus, 
				cols,
				currentAnchor,	
				currentposition,
                currentLength = this._data.length,
				elem1,
				end,
				finalIndex,
				i,
				imgPreloaderIdx,
				items,
				list,
				maxItems,
				o,
				pagingModifier,
				pos,
				row,
				spamming = false, //$cn.utilities.DateDiff(new Date(), this.lastMovement) < 750;
				start,
				tmpImgArr,
				top,
				topLeft,
				totalheight, 
				visibleheight,  				
				x,
				animationFPS = animation.options.fps,
				animationTransition = animation.options.transition;
			
			this.lastMovement = new Date();
			
			if(this.hault == 0)
			{
				currentposition = '';
				list 			= $('titlelist');
				items 			= list.getChildren();
				totalheight 	= this.totalRecords;
				currentAnchor 	= (items[0]) ? items[0].getElements('a')[0] : null;
				cols 			= this.config.numCols;
				maxItems 		= this.config.numDisplay;
				finalIndex 		= parseInt(this.totalRecords) -1; //Last Index of Current Dataset
				pagingModifier 	= rows;
				visibleheight 	= items.length;
				cleanupFocus 	= false; // This is here in case the focus is lost. It will be set to the last item in the list if there is no currentAnchor.
				
				this.currentTopLeft = (currentAnchor) ? 
						(currentAnchor.get('titleidx') != null ? parseInt(currentAnchor.get('titleidx')) : -1) :
						(finalIndex  + 1);
				cleanupFocus = (!currentAnchor);
				
				row = Math.floor(this.currentTopLeft / cols);
                log.write("============== items requested is: " + this.itemsRequested);
				if(direction == "up")
				{
                    log.write("===== moving on up ========");
                    // Removing loading spinner for prefetch if we move up as a user experience detail
                    if (this.prefetchSpinner) {
                        application.events.publish('gridloaded', {grid: this.id});
                        this.prefetchSpinner = false;
                    }

					if (row > 0) {
						
						this.hault = 1;
						//var pos = (pagingModifier != 1) ? Math.min(0, row - rows) : Math.max(0, row - rows),
						// pos = 
						// Even out the rows for optimal scrolling back up and stopping on first row
						pos = Math.max(-rows, row - rows); // ???
						
						while (pos % rows !== 0) {
							++pos;
							--pagingModifier;
						}
						topLeft = pos * cols;
						animationDuration = (pagingModifier == 1) ? animationDuration : animationDuration * 2;

						if(((1000 / animationFPS) * 2) >= animationDuration) {
							animationDuration = 100;
							animationFPS = 1000 / animationDuration;
						}
						
						
						for (i = parseInt(this.currentTopLeft) - 1; i >= topLeft; --i) {
							//log.write("Adding title at " + i);
							if(this._data[i]) {
								this._data[i].titleidx = i;
								this.tpl.prepend(this._data[i]);
							}
						}						
						
						this.tpl.apply();
                        $$('#titlelist .title img').each(function(item){
                            item.onerror = function(e){
                                log.write("IMAGE ERROR");
                                item.hide();
                            }
                        });

                        //Custom default image function for themes that want more than 1 default image
                        if (typeof $cn.config.CustomDefaultGridImage == 'function') {
                            $$('#titlelist .title .title-text').each(function(item) {
                                var className = $cn.config.CustomDefaultGridImage(item);
                                item.addClass(className);
                            });
                        }
                        items = list.getChildren();												
						top = (pos - row) * (this.rowHeight) + 1;						
						for (i = 0; i < (cols * pagingModifier) && (i < items.length); i++) {							
							items[i].setStyle("margin-top", top);							
						}
						
						o = {};
						
						for(i=0; i <  (cols*pagingModifier); i++) {
							if(i < items.length) {
								o[i] = {'margin-top': '1px'};
							}
						}
						
						if(device.getDeviceSoc() != "BCOM") {
					
						    // We need to block the enter key until the scroll finishes.
						    // This prevents bugs when the user enters Title Details before the
						    // scroll finishes. We'll set the TempKeyBlockDuration to some time
						    // *greater* than the animation duration, as setting it exactly equal
						    // doesn't always allow the animation to finish (too close or a delay
						    // somewhere perhaps). We make it exact by turning the block back off
						    // once the animation completes anyway.
							application.TempKeyBlockEnter = true;
							application.TempKeyBlockDuration = animationDuration*2;     // as a maximum
							elem1 = new Fx.Elements(items, {
								duration: (spamming) ? 0 : animationDuration, 
                        					fps: animationFPS,
								transition: animationTransition,
								onComplete: function(obj){
                                    // Re-enable the enter key now that the shift is done.			
	    							application.TempKeyBlockEnter = false;

									//Hide the top fade on the first row
									if(this.currentTopLeft == 0 && this.showFade){
										$('HorizontalFadeTop').hide();
									}
								
									if(cleanupFocus) {
										if(items[items.length] && items[items.length].id) {
											navigation.setFocus(items[items.length].id);
										}
										else {
											navigation.setFocus("singleselectedmaster");
										}
									}
									
									setTimeout(function(){
										var i;
										application.currentView.layoutIsDirty = true; 
										
										for (i = items.length - 1; i >= maxItems; --i) {
											log.write("Removing title at " + i);
											items[i].destroy();
										}
											
										this.config.numStartIndex = topLeft;
										this.hault = 0;
										
									}.bind(this),200);
									
								}.bind(this)
							});

							elem1.start(o);
						}
						else {
							for (var x = 0; x < items.length; ++x) {
								items[x].setStyles(o[x]);
								
								//Hide the top fade on the first row
								if(this.currentTopLeft == 0 && this.showFade){
									$('HorizontalFadeTop').hide();
								}
							
								if(cleanupFocus) {
									if(items[items.length] && items[items.length].id) {
										navigation.setFocus(items[items.length].id);
									}
									else {
										navigation.setFocus("singleselectedmaster");
									}
								}
								
								setTimeout(function(){
									var i;
									application.currentView.layoutIsDirty = true; 
									
									for (i = items.length - 1; i >= maxItems; --i) {
										log.write("Removing title at " + i);
										items[i].destroy();
									}
										
									this.config.numStartIndex = topLeft;
									this.hault = 0;
									
								}.bind(this),200);
							}
							
						}
						this.currentTopLeft = topLeft;
						BrowseView.ScrollBar.setPosition(pos);
						
						//Cleanup
						elem1 = null;						
					}
				}
				else if(direction == "down")
				{
                    log.write("============ prefetch spinner is: " + this.prefetchSpinner);
					if (row < BrowseView.ScrollBar.range) {
						log.write("row: " + row + " range: " + BrowseView.ScrollBar.range);		
						//Hide the top fade on the first row
						if(this.showFade){
							$('HorizontalFadeTop').show();
						}
						
						this.hault = 1;
						//
						
						//var pos = (pagingModifier != 1) ? Math.max(BrowseView.ScrollBar.range, row + rows) : Math.min(BrowseView.ScrollBar.range, row + rows),
						pos = Math.min(BrowseView.ScrollBar.range, row + rows);
						topLeft = pos * this.config.numCols;
						animationDuration = (pagingModifier == 1) ? animationDuration : animationDuration * 2;
						start = parseInt(this.currentTopLeft) + items.length; //parseInt(items[items.length - 1].getElement('a').get('titleidx')) + 1;
						end = Math.min(finalIndex, topLeft + this.config.numDisplay);
						//log.write("start=" + start + ", end=" + end + ", currentTopLeft=" + this.currentTopLeft + ", items.length=" + items.length + ", finalIndex=" + finalIndex + ", topLeft=" + topLeft + ", this.config.numDisplay=" + this.config.numDisplay);
						
						//This is here to handle the case where the user modifies the grid by scrolling a single row then moves over to the scrollbar and tries to page down. 
						//Before this check we could over-run the bounds and show an empty grid.
						if(start >= end) {

							pagingModifier = 1;
							pos = Math.min(BrowseView.ScrollBar.range, row + pagingModifier);
							topLeft = pos * this.config.numCols;
							animationDuration = (pagingModifier == 1) ? animationDuration : animationDuration * 2;
							start = parseInt(this.currentTopLeft) + items.length;
							end = Math.min(finalIndex, topLeft + this.config.numDisplay);
						}

						if(((1000 / animationFPS) * 2) >= animationDuration) {
							animationDuration = 100;
							animationFPS = 1000 / animationDuration;
						}

                        // things got updated while we were on the page
                        //log.write('end = ' + end + ', currentLength = ' + currentLength);
                        if (end > currentLength) {
                            // Stop scrolling
                            pagingModifier = rows = 0;
                            log.write("======= user scrolled to end of page =======================");
                            if (this.itemsRequested) {
                                this.prefetchSpinner = true;
                                application.events.publish('gridloading', {grid: 'titlegrid', message: "loading", columns: this.numColumns});
                            }
                        }
						
						log.write("this.currentTopLeft: " + this.currentTopLeft + " finalIndex: " + finalIndex + " pos: " + pos + " topLeft: " + topLeft + " start: " + start + " end: " + end + " items.length: " + items.length);
						//Check if we can do this. This removes the limitation for only displaying 999 titles and loads them in a chunk at a time.
						if(!this._data[end + $cn.data.PAGE_PRE_FETCH]){
                            log.write("===== Getting ready to make pre fetch page call (itemsRequested=" + this.itemsRequested + ") ========");
							if(this.currentPage < this.totalPages) {
								//Has a request been made recently
								if(!this.itemsRequested) {
									this.currentPage++;
									this.itemsRequested = true;
									log.write('before method. currentPage = ' + this.currentPage + ', items = ' + this._data.length);
									
									this.loadPage(this.currentPage);
								}
							} else {
							    log.write('pre-fetch call not made. currentPage:' + this.currentPage + ' is >= totalPages:' + this.totalPages);
							}
						}
						
						//Passed test...proceed
						log.write("Rendering items " + start + " to " + end);
						tmpImgArr = [];
						
						if (start <= end)
						{
							imgPreloaderIdx = 0;
							
							// Guessing x should not be global, so vared it, up top [3/14/2012 change x<=end to x<end found that it was rendering one extra images under the visible bounds.]
                            // < causes a one off error by displaying one less item than there actually is
							for(x = start; x <= end; x++) {
								//log.write("Adding title at " + x);
								if(this._data[x]) {
									this._data[x].titleidx = x;
									this.tpl.append(this._data[x]);	
									
									if(!spamming) {
										//Preload next image
										if(this._data[x + (pagingModifier * cols)]) {
											tmpImgArr[imgPreloaderIdx] = new Image();
											tmpImgArr[imgPreloaderIdx].src = "http://cache.cinemanow.com/images/boxart/v2_107/" + this._data[x + (pagingModifier * cols)].boxartPrefix + "v2_107.jpg";
											imgPreloaderIdx++;
										}
									}
								}
							}
		
							this.tpl.apply();
                            $$('#titlelist .title img').each(function(item){
                                item.onerror = function(e){
                                    log.write("IMAGE ERROR");
                                    item.hide();
                                }
                            });

                            //Custom default image function for themes that want more than 1 default image
                            if (typeof $cn.config.CustomDefaultGridImage == 'function') {
                                $$('#titlelist .title .title-text').each(function(item) {
                                    var className = $cn.config.CustomDefaultGridImage(item);
                                    item.addClass(className);
                                });
                            }

                            items = list.getChildren();

						}
						
						tmpImgArr = null;
						o = {};
						for(i=0; i < (cols*pagingModifier); i++) {
							if(i < items.length) {
								o[i] =  {'margin-top': -(this.rowHeight*pagingModifier)};
							}
						}
						
						if(device.getDeviceSoc() != "BCOM") {
						    // We need to block the enter key until the scroll finishes.
						    // This prevents bugs when the user enters Title Details before the
						    // scroll finishes. We'll set the TempKeyBlockDuration to some time
						    // *greater* than the animation duration, as setting it exactly equal
						    // doesn't always allow the animation to finish (too close or a delay
						    // somewhere perhaps). We make it exact by turning the block back off
						    // once the animation completes anyway.
							application.TempKeyBlockEnter = true;
							application.TempKeyBlockDuration = animationDuration*2;     // as a maximum
							elem1 = new Fx.Elements(items, {
								duration: (spamming) ? 0 : animationDuration, 
								fps: animationFPS,
								transition: animationTransition,
								onComplete: function(obj){
                                    // Re-enable the enter key now that the shift is done.			
	    							application.TempKeyBlockEnter = false;

									application.currentView.layoutIsDirty = true; 
									this.hault = 0;
									
									for(i=0; i < items.length; i++) {
										if(items[i].style.marginTop && parseInt(items[i].style.marginTop.replace("px", '')) < 0){
											items[i].destroy();		
										}
									}
									
	//								for (var x = topLeft - this.currentTopLeft - 1; x >= 0; --x) {
	//									log.write("Deleting title at " + x);
	//									items[x].destroy();								
	//								}
	
									log.write("Deleted overflow titles.");
									
									this.config.numStartIndex = topLeft;
					
								}.bind(this)
							});
							
							elem1.start(o);
						}
						else {
							for (var x = 0; x < items.length; ++x) {
								items[x].setStyles(o[x]);
							}
							
							application.currentView.layoutIsDirty = true; 
							this.hault = 0;
							
							for(i=0; i < items.length; i++) {
								if(items[i].style.marginTop && parseInt(items[i].style.marginTop.replace("px", '')) < 0){
									items[i].destroy();		
								}
							}

							log.write("Deleted overflow titles.");
							
							this.config.numStartIndex = topLeft;
						}


                        var currentIndex = parseInt($(application.element.current).get('titleidx'), 10);
                        if (currentIndex + 1 + cols >= this.totalRecords - cols) {
                            log.write("*********** bottom of page *****************");
                            pos = BrowseView.ScrollBar.range;
                        }

						BrowseView.ScrollBar.setPosition(pos);
						
						//Cleanup
						elem1 = null;
					}
				}
				
				list = null; 
				currentAnchor = null;			
			}
		},
		navigate: function(payload){

			if(this.isActive){
				
				this.lastNavigationDirection = payload.args[0].direction;
				
				if(payload.args[0].direction == 'up'|| payload.args[0].direction== 'down') 
				{
					payload.preventDefault();
					log.write("hault: " + this.hault);
					if(this.hault != 1) {
		                var cancel = false,
                            list = $('titlelist'),
                            items = list.getChildren(),
                            direction = payload.args[0].direction,
                            currentIndex = parseInt($(application.element.current).get('titleidx'), 10),
                            nextIndex = currentIndex + (direction == "up" ? -this.config.numCols : this.config.numCols);
						
						if (nextIndex >= this.totalRecords ) {
							if (Math.floor((this.totalRecords - 1) / this.config.numCols) > Math.floor(currentIndex / this.config.numCols))
								nextIndex = this.totalRecords - 1;
						} 
		
						if (nextIndex >= 0 && nextIndex < this.totalRecords) {
							this.currentTopLeft = parseInt(items[0].getElements('a')[0].get('titleidx'));

							if (nextIndex < this.currentTopLeft) {
								this.movegrid("up", 1)
							}
							else if ((nextIndex >= this.currentTopLeft + this.config.numDisplay)) {
                                if (this.prefetchSpinner) {
                                    cancel = true;
                                } else {
								    this.movegrid("down", 1);
                                }
							}
							else {
								var item = items[nextIndex - this.currentTopLeft]; //list.getElement("a[titleidx='"+nextIndex+"']");

                                // Bail if things are going to get ugly
                                if (!item)
                                    return;

								if ((item.getPosition().y + item.getSize().y) > $('titlemeta').getPosition().y){
									this.movegrid("down", 1);
							}
							}

                            if (!cancel) {
							    var focusElement = list.getElement("a[titleidx='"+nextIndex+"']");
							    navigation.setFocus(focusElement);
                            }
						}
					} //end this.hault check
				}
				else if(payload.args[0].direction == 'left') {
					if (this.itemidx % this.config.numCols == 0) {
						if (this.returnFocus) {
							navigation.setFocus(this.returnFocus);
							payload.preventDefault();
						}
					}
					else {
						nextIndex = this.itemidx - 1;
						navigation.setFocusElement($('titlelist').getElement("a[titleidx='"+nextIndex+"']"));	
						payload.preventDefault();
						
						/*
						 * var nextIndex = parseInt(application.element.current.replace('app-gen-', '')) - 1;
						var elem = document.getElementById('app-gen-' + nextIndex);
						
						if(elem) {
							navigation.setFocus(elem.id);	
							payload.preventDefault();
						}
						 */
					}
				} 
				else if(payload.args[0].direction == 'right') {
					
					payload.preventDefault();

					if (this.itemidx % this.config.numCols == this.config.numCols - 1 || this.itemidx == this.totalRecords - 1) { 
						if (document.getElementById('scrollbar') && document.getElementById('scrollbar').style.display == "block") {
							navigation.setFocus(BrowseView.ScrollBar.thumb);
						}
					}
					else {
						nextIndex = this.itemidx + 1;
						var nextElem = $('titlelist').getElement("a[titleidx='"+nextIndex+"']"); 
						
						if(nextElem) {
							navigation.setFocusElement($('titlelist').getElement("a[titleidx='"+nextIndex+"']"));
						}
					}
				} 
			}
			else if ((application.element.current && application.element.current != '') && document.getElementById(application.element.current) && application.element.current == BrowseView.ScrollBar.thumb) {
				if (payload.args[0].direction == 'left' && $('titlelist').getSize().y) {
					
					if(this.hault == 0) {
						var results = $('titlelist').getElementsByTagName("a");
						var idx = Math.min(results.length - 1, this.config.numCols - 1);

						if (results.length > idx)
						 {
							application.navigator.setFocusElement(results[idx]);
							payload.preventDefault();
						}
					}
					else {
						payload.preventDefault();
					}
				}
			}
		},
		onSaveState: function(payload){
			var state = payload.args[0];
			state[this.id] = {
				_data: this._data,
				tpl: this.tpl,
				isActive: this.isActive,
				rowHeight: this.rowHeight,
				returnFocus: this.returnFocus,
				hault: 0,
				currentPage: this.currentPage,
				totalRecords: this.totalRecords,
                totalPages: this.totalPages,
				itemidx: this.itemidx,
                genreid: this.genreid,
				config: $extend({}, this.config),
				showFade: this.showFade,
				itemsRequested: this.itemsRequested
			};
			this.itemsRequested = false;    // resume on restore.
		},
		onRestoreState: function(payload){
			var state = payload.args[0];
			$extend(this, state[this.id]);
            this.config = $extend({}, state[this.id].config);
			//alert(state[this.id].returnFocus);
			if (this.itemsRequested) {
			    // If a request was pending, kick it off again.
			    this.loadPage(this.currentPage);
			}
		},
		onHandleError: function(payload){
		    // If items were requested, reset the variables so they can load again.
		    // This is not an ideal solution: if the user hits "Try Again", which
		    // happens after this, then the call will complete, but the results will
		    // be thrown away. Of course, they will be cached, so the next call
		    // will be quick, but it is still a bit of a waste.
		    // The ultimate solution would be to use different calls for the background
		    // calls so that errors can be handled directly.
		    if (this.itemsRequested) {
		        this.currentPage--;
		        this.itemsRequested = false;
		    }
		}
		
	},
	GridControl = new Class(GridControlProperties);
//-----------------------------------------------------------------------------
// gridcontroller.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var ActiveGrid = null;
var GridController = new Class({
	DEBUG: false,
	registeredControls: {},
	spinnerPos: 1,
    spinnerTimer: null,
    spinnerSpinning: false,
    spinnerPosition: 1,
	initialize: function(){
		application.events.subscribe(this, 'loadgrid', this.activate.bind(this));
		application.events.subscribe(this, 'gridloading', this.handleGridLoading.bind(this));
		this.spinnerTimer = new Timer();
		this.spinnerTimer.Interval = 80;	
	},
	activate: function(payload){
		
		if (this.DEBUG) log.write("gridcontroller.activate Debug: Enter with payload " + log.dumpObj(payload));

    	payload = payload.args[0];
		
		//Only do this if the current payload matches the latest store grid process. This is necessary because of quick navigation with async callbacks. We should only be doing the last grid operation so there is no erronous grid loads.
		if(BrowseView.LastGridProcess == payload.gridProcess) {
			log.write('gridcontroller.activate Debug: Loading grid...position is ' + payload.position);
	
			var element;
	
			if (ActiveGrid != null && payload.grid != ActiveGrid.id) {
				if (this.DEBUG) log.write('gridcontroller.activate Debug: Hiding active grid.');
				element = $(ActiveGrid.id);
				element.hide();
			}
	
			var className = payload.className ? payload.className : '';
			
			ActiveGrid = this.registeredControls[payload.grid];
			ActiveGrid.className = className;
			ActiveGrid.altMessage = payload.altMessage;
			ActiveGrid.returnFocus = payload.returnFocus;
			ActiveGrid.showFade = payload.showFade;
			
			element = $(ActiveGrid.id);
			element.className = className;
			
			if (payload.position) {
				if (this.DEBUG) log.write("gridcontroller.activate Debug: payload.position set, calling ActiveGrid.redraw passing data" + log.dumpObj(payload.data));
				ActiveGrid.redraw(payload.data);
			}
			else {
				var length = (!payload.data) ? 0 : payload.data.length;
				length = (length != 0 && (payload.customLength && payload.customLength > payload.data.length)) ? payload.customLength : length;
				if (this.DEBUG) log.write("gridcontroller.activate Debug: payload.position NOT set, Calling ActiveGrid.loadData passing data of length " + length + ": " + log.dumpObj(payload.data)); 
				ActiveGrid.loadData(payload.data, payload.columns, payload.template, payload.position, length, (payload.customPages) ? payload.customPages : 1, payload.genreid);
			}
			
			element.show();
	
			application.currentView.layoutIsDirty = true;
		}
	},
	hideAll: function()
	{
		ActiveGrid = null;
		for (var item in this.registeredControls) {
			$(this.registeredControls[item].id).hide();
		}
//		this.registeredControls.each(function(ctl){
//			$(ctl.id).hide();
//		});
	},
	initSpinner: function(){
		log.write('Init Spinner');
		BrowseView.GridController.spinnerTimer.Tick = BrowseView.GridController.spinnerTick;
        if(!BrowseView.GridController.spinnerSpinning) {
        	$('gridspinnercontainer').hide();
        	BrowseView.GridController.spinnerPosition = 1;
        	BrowseView.GridController.spinnerTimer.Start();
        	BrowseView.GridController.spinnerSpinning = true;
        }
       
	},
	deinitSpinner: function(){
		BrowseView.GridController.spinnerTimer.Stop();
		BrowseView.GridController.spinnerSpinning = false;
		$('gridspinnercontainer').hide();
//		$('gridloadingprocessstring').hide();
	}
	,spinnerTick: function(){
		

//		log.write('tick: ' + BrowseView.GridController.spinnerPosition);
		var spinner = document.getElementById('gridspinner');
		if (spinner) {
		
			var red = false; //[REMOVED PER SONIC DIRECTION] $('uicontainer').className == 'redbuttons';
			
			var vstart1 = -413;
			var vstart2 = -461;
			
			if(!red) {
				vstart1 = -1004;
				vstart2 = -1052;
			}
			BrowseView.GridController.spinnerPosition = (BrowseView.GridController.spinnerPosition + 1) % 16;
			

			var hpos = BrowseView.GridController.spinnerPosition * 80 * -1;
			var vpos = vstart1;
			
			if(BrowseView.GridController.spinnerPosition > 7) {
				hpos = (BrowseView.GridController.spinnerPosition - 8) * 80 * -1;
				vpos = vstart2;
			}
							
			spinner.style.backgroundPosition = parseInt(hpos) + 'px ' + vpos + 'px';
			$('gridspinnercontainer').show();
		}
	},
	register: function(ctl){
		this.registeredControls[ctl.id] = ctl;
	},
	handleGridLoading: function(payload){
		payload = payload.args[0];
		var element;

		if (ActiveGrid != null && payload.grid != ActiveGrid.id) {
			element = $(ActiveGrid.id);
			element.hide();
		}

		var className = payload.className ? payload.className : '';
		
		ActiveGrid = this.registeredControls[payload.grid];
		ActiveGrid.className = className;
//		ActiveGrid.altMessage = payload.altMessage;
//		ActiveGrid.returnFocus = payload.returnFocus;
//		ActiveGrid.loadData(payload.data, payload.columns, payload.template, payload.position);
			
		element = $(ActiveGrid.id);
		element.className = className;
		element.show();

		application.currentView.layoutIsDirty = true;
	}	
});
//-----------------------------------------------------------------------------
// helppanel.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var HelpPanelControl = new Class({
	id: 'helppanel',
	persist: {},
    controls:{},
    layoutIsDirty: true,
    contentId: "helppanel",
    tpl: null,
    initialize: function(){
    	$('helppanel').hide();

		log.write('helppanel.init()');		
	    application.events.subscribe(this, 'wheelitemchanged', this.handleSettingWheelChange.bind(this));
	 
	    this.tpl = new ui.template(this.contentId, application.ui.loadTpl(this.id + ".tpl"));
		this.tpl.compile();

    },
    handleSettingWheelChange: function(payload) {
    	
    	var data = payload.args[0];
    	
    	if(data.wheelinstance == 'HelpWheelControl') {
    		log.write('Help Panel (wheel changed)');
    		log.write(data);
        	
    		//this.loadView(data.selectedvalue);
    		$$("#helppanel .panel").each(function(item) { item.hide(); });
    		log.write('selected: ' + data.selectedvalue);
    		if($(data.selectedvalue))
    		{
    			$(data.selectedvalue).show();
    		}
    
    	}
    },
    hideIfNoBaseline: function(i){
    	var val = "";
    	
    	if(!$cn.data.baselineEnable) {
    		val = "hide";
    	}
    	
    	return val;
    },
    showIfNoBaseline: function(i){
    	var val = "";
    	
    	if($cn.data.baselineEnable) {
    		val = "hide";
    	}
    	
    	return val;
    },
    hideIfNoJinni: function(i){
    	var val = "";
    	
    	if(!$cn.data.jinniEnable) {
    		val = "hide";
    	}
    	
    	return val;
    },
    showIfNoJinni: function(i){
    	var val = "";
    	
    	if($cn.data.jinniEnable) {
    		val = "hide";
    	}
    	
    	return val;
    },
    show: function() {
    	$('helppanel').show();
    	this.tpl.append({'custom': ''});
    	this.tpl.apply();
    },
    hide: function(){
    	$('helppanel').hide();
    },
    getAccountLinkUrl: function() {
        return $cn.data.AccountLinkUrl;
    },
    tm: function() {
        return '&#0153;';
    }
});
//-----------------------------------------------------------------------------
// helpwheel.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author atumminaro
 */
var HelpWheelControl = new Class({
	Extends: WheelControl,
	id: 'HelpWheelControl',
	container: 'singlewheel',
	singleWheel: true,
	MetaData: [],
    masterSourceElement: 'singlemasterdatasource',
    masterSelectedElement: 'singleselectedmaster',
	handleWheelItemChange: function(payload){		
		log.write(payload);
		
		if(payload.context === ActiveWheel) {
			var p = payload.args[0];
			log.write("Search Wheel Item changed. Now fire custom method. " + payload.args[0].wheelinstance);
			/* If the source is the master column then load the slave wheel with the child elements from the new selection */
			application.events.publish('wheelvaluechanged', {
				selectedvalue: p.selectedvalue,
				wheelinstance: this.id
			});
		}
	},
	loadHelpMenu: function() {
		application.currentView.layoutIsDirty = true;
		this.cleanUI();
		
        if ($cn.config.EnableUV) {
            this.loadData([{
                    name: application.resource.HelpWheelOptionStrings.GettingStarted,
                    iD: "GettingStarted",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.BrowsingStore,
                    iD: "BrowsingStore",
                    parentID: 0,
                    list: 0
                },{
                    name: application.resource.HelpWheelOptionStrings.Searching,
                    iD: "Searching",
                    parentID: 0,
                    list: 0
                },{
                    name: application.resource.HelpWheelOptionStrings.WishList,
                    iD: "WishList",
                    parentID: 0,
                    list: 0
                },{
                    name: application.resource.HelpWheelOptionStrings.Library,
                    iD: "Library",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.ParentalControls,
                    iD: "ParentalControls",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.OnscreenControls,
                    iD: "OnscreenControls",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.CustomerSupport,
                    iD: "CustomerSupport",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.RentingBuying,
                    iD: "RentingBuying",
                    parentID: 0,
                    list: 1
                },{
                    name: application.resource.HelpWheelOptionStrings.Ultraviolet,
                    iD: "Ultraviolet",
                    parentID: 0,
                    list: 1
                }], [{}]
            );	
        } else {
            this.loadData([{
                name: application.resource.HelpWheelOptionStrings.GettingStarted,
                iD: "GettingStarted",
                parentID: 0,
                list: 1
            },{
                name: application.resource.HelpWheelOptionStrings.BrowsingStore,
                iD: "BrowsingStore",
                parentID: 0,
                list: 0
            },{
                name: application.resource.HelpWheelOptionStrings.Searching,
                iD: "Searching",
                parentID: 0,
                list: 0
            },{
                name: application.resource.HelpWheelOptionStrings.WishList,
                iD: "WishList",
                parentID: 0,
                list: 0
            },{
                name: application.resource.HelpWheelOptionStrings.Library,
                iD: "Library",
                parentID: 0,
                list: 1
            },{
                name: application.resource.HelpWheelOptionStrings.ParentalControls,
                iD: "ParentalControls",
                parentID: 0,
                list: 1
            },{
                name: application.resource.HelpWheelOptionStrings.OnscreenControls,
                iD: "OnscreenControls",
                parentID: 0,
                list: 1
            },{
                name: application.resource.HelpWheelOptionStrings.CustomerSupport,
                iD: "CustomerSupport",
                parentID: 0,
                list: 1
            },{
                name: application.resource.HelpWheelOptionStrings.RentingBuying,
                iD: "RentingBuying",
                parentID: 0,
                list: 1
            }], [{}]
            );
        }
	
		application.events.publish('wheelvaluechanged', {
			selectedvalue: "GettingStarted",
			wheelinstance: this.id
		});
		
	}
});
//-----------------------------------------------------------------------------
// imagepopup.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var ImagePopup = new Class({
	Extends:ModalControl,
	id: 'imagepopup',
	currentIdx: 0,
	initialize: function(){
		application.events.subscribe(this, "navigate", this.navigate.bind(this));
		this.parent(this.id, "ImageContent");

	},
	/*
	

	 */
	navigate: function(payload) {
		
		if(document.getElementById(application.element.current) != null && application.element.current == "closeImagePopup"){
			if(payload.args[0].direction == 'left'|| payload.args[0].direction== 'right')
			{
				$('ImageContent').getChildren("div.imageholder")[this.currentIdx].hide();
				switch(payload.args[0].direction)
				{
					case "left":
						if(this.currentIdx > 0)
						{
							this.currentIdx = this.currentIdx - 1;
						}
						break;
					case "right":
						if(this.currentIdx + 1 < this._data.length)
						{
							this.currentIdx = this.currentIdx + 1
						}
						break;
				}
				$('ImageContent').getChildren("div.imageholder")[this.currentIdx].show();
				this.setArrows();
			}
		}
	},
	setArrows: function() {
		$("rightArrow").hide();
		$("leftArrow").hide();
		if(this.currentIdx > 0)
		{
			$("leftArrow").show();
		}
		
		if(this._data.length > 1 && this._data.length - 1 != this.currentIdx)
		{
			$("rightArrow").show();
		}
		
	},
	show: function(idx) {
		
		if(idx)
			this.currentIdx = idx;
		else
			this.currentIdx = 0;
		
		
		this.lastFocus = application.element.current;
		navigation.setFocus('closeImagePopup');
		BrowseView.hideLogo();
		$('dock').hide();
		$('uicontainer').setStyle('background','none');
		$('mainstage').hide();
		$('imagepopup').show();
		$('closeImagePopup').show();
		$('ImageContent').getChildren("div.imageholder")[this.currentIdx].show();
		this.setArrows();
	},
	hide: function() {
		navigation.setFocus(this.lastFocus);
		$('closeImagePopup').hide();
		$('imagepopup').hide();
		$('uicontainer').setStyle('background','#181818');
		
		BrowseView.showLogo();
		$('dock').show();
		$('ImageContent').getChildren("div.imageholder").hide();
		$('mainstage').show();
		

	},
});
//-----------------------------------------------------------------------------
// keyboard.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author jmccabe
 */
var KeyboardControl = new Class({
	id: 'keyboard',
	persist: {},
    controls:{},
    layoutIsDirty: true,
    swappedState: 'standard',
    tpl: null,
    _currentValue: '',
    initialize: function(){
        application.element.registerControl(this);
        
        application.events.subscribe(this, "keyboardback", this.keyback.bind(this));
        application.events.subscribe(this, "keyboardclear", this.keyclear.bind(this));
        application.events.subscribe(this, "keyboardselect", this.keyselect.bind(this));
        application.events.subscribe(this, "keyboardswap", this.keyboardswap.bind(this));
        
        
	    //application.events.subscribe(this, 'elementblur', this.gridBlur.bind(this));
        //application.events.subscribe(this, 'elementfocus', this.keyboardFocus.bind(this));
		application.events.subscribe(this, 'savestate', this.onSaveState.bind(this));
		application.events.subscribe(this, 'restorestate', this.onRestoreState.bind(this));
    },
    init: function(params, direction){
		log.write('searchkeyboard.init()');		
        var self = this;

        //Persist Params
        if(params) {
            this.persist = params;               
        }      
	},
	cleanUI: function(){
		
	},
	/*
	 * Load data will:
	 * 1) Set the HTML source and buttons for the modal view
	 * 2) Render the local controls
	 */
	loadData: function(title) {
		this.persist.title = title;		
		this.draw();		
	},
	/* Read config values and render grid */
	draw: function(){
		this.cleanUI();
		
		
	},
	keyback: function(payload) {
		this._currentValue = this._currentValue.substring(0, this._currentValue.length - 1);
		this.valuechange(payload);		
	},
	keyclear: function(payload) {
		this._currentValue = '';
		$('SearchText').set('html', '_');
		this.valuechange(payload);
		
	},
	keyselect: function(payload) {
		log.write('keyboard select:' + payload.args[0].value);
		log.write(payload);
		if(this._currentValue.length < 11)
			this._currentValue +=  payload.args[0].value;
		this.valuechange(payload);
	},
	valuechange: function(payload) {	
		if(payload && payload.args[0].caller == this.id) {
			if (this._currentValue.length < 11) {
				$('SearchText').set('html', this._currentValue + '_');
			} else {
				$('SearchText').set('html', this._currentValue);
			}		
			this.handlechange();
			
			application.events.publish('keyboardvaluechanged', {
				currentValue: this._currentValue
				
			});
		}
	},
	handlechange: function() {
		//METHOD TO BE OVERRIDDEN 
	},
	keyboardswap: function(payload) {
		log.write('keyboard swap');
		
		
		switch(payload.args[0].value) {
			case "alt":
				log.write($$("a.standard").each(function(item){item.hide()}));
				log.write($$("a.alt").each(function(item){item.show()}));
				navigation.setFocus('KeyboardStandardSwap');
				this.swappedState = "alt";
				break;
			default :
				log.write($$("a.alt").each(function(item){item.hide()}));
				log.write($$("a.standard").each(function(item){item.show()}));
				navigation.setFocus('KeyboardAltSwap');
				this.swappedState = "standard";
				break;
		}
		application.currentView.layoutIsDirty = true;		
        navigation.buildNavigation($('keyboard').getElements('a'));
	},
	show: function (){
		document.getElementById('keyboard').className = this.id;
		this._currentValue = '';
		
		//this.keyboardswap({args:[{value: "standard"}]});
		this.swappedState = "standard";
		application.currentView.layoutIsDirty = true;		
        navigation.buildNavigation($('keyboard').getElements('a'));
		$("keyboard").show();
	},
	hide: function()
	{
		document.getElementById('keyboard').className = '';
		//this._currentValue = '';
		$("keyboard").hide();
	},
	onSaveState: function(payload){
		var state = payload.args[0];
		state[this.id] = {
			_currentValue: this._currentValue,
			swappedState: this.swappedState
		};
	},
	onRestoreState: function(payload){
		var state = payload.args[0];
		$extend(this, state[this.id]);
	}
});
//-----------------------------------------------------------------------------
// legalpopup.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var LegalPopup = new Class({
	Extends:ModalControl,
	scrollview: null,
    initialize: function(id){
    	this.parent(id);
	},
    setCssClass: function(id) {
        var cssClass = (id == "uvtermsofservice" ? id : 'legal');
		this.parent(cssClass);
    },
	draw: function(){
		this.parent();
		var scrollview = $(this.contentId).getElement(".scroll");
			
		if (scrollview) 
			this.scrollview = new ScrollView(scrollview);
	},
	show: function(theCallback) {
        if (theCallback) {
            this.theCallback = theCallback;
        }
		this.parent();

		// Scrollbar must be drawn after the call to show() 
		// in order to correctly determine scrolling extents
		if (this.scrollview)  {
			this.scrollview.draw();
		}
	},
	hide: function(){
		this.parent();

		if (this.scrollview)
			this.scrollview.destroy();

        if (this.theCallback) {
            this.theCallback();
        }
	},
	onBack: function(payload){
		
		if (this.id == "eula") {
			payload.preventDefault();
		}
		else {
			this.parent(payload);
		}
	}
});
//-----------------------------------------------------------------------------
// library.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
var LibraryClass = {
		id: 'librarypanel',
		isInvalid: false,
		tplKey: null,
		tpl: null,
		_data: [],
		scroll: false,
		_timer: 600, //600 seconds = 10 minutes
		_periodical: '',
		_timerStarted: false,
		initialize: function(id){
			application.events.subscribe(this, "navigate", this.handleNavigate.bind(this));
			application.events.subscribe(this, "restorestate", this.onRestoreState.bind(this));
			
			this.id = id;
			this.tplKey = this.id;
			//log.write(this.id + ".tpl");
			
			this.tpl = new ui.template(this.id, application.ui.loadTpl(this.id + ".tpl"));
			this.tpl.compile();

			log.write(this.id + ".init()");		
		},
		cleanUI: function(){
			if($(this.id).getChildren().length > 0){
				$(this.id).getChildren().destroy();
			}
		},
		setFocus: function() {
			if($('librarypanel').getStyle("display") == "block")
			{
				if($("btnLibraryActivate").getStyle("display") == "block")
					navigation.setFocus('btnLibraryActivate');
				else
					navigation.setFocus("btnLibraryBrowseStore");
			}
			else
			{
				navigation.setFocus("selectedmaster");
			}
			//this.startRefresh();
		},
		show: function(){
			var self = this;
			log.write('triggered show');
			$('mainstage').show();
			if($cn.data.AuthToken.length == 0){
				BrowseView.hideExtras();
				$("librarypanel").show();
				$("librarytop").show();
				
				$("librarytop").getElement(".buttons").addClass("double");
				$$(".libraryActivate").show();
				this.setFocus();
                if (BrowseView.MessagePopup) {
                    BrowseView.MessagePopup.resetFocus();
                }
			}
			else {
				BrowseView.CurrentProcessLoaded = false;

                // This is a continuation of a store spinner, so it should show right away
                $cn.utilities.showSharedLoadingModal(0, application.resource.loading_enum.library);
				$cn.methods.getUserLibraryExt(function(result){

                    // Clear timer for loading modal
                    $cn.utilities.clearSharedLoadingSpinner();

					if (result.items.length > 0) {
						
						$("librarypanel").hide();
						$("librarytop").hide();
						$('wheel').show();
						$('singlewheel').hide();

						if (!BrowseView.LibraryWheelControl)
							BrowseView.LibraryWheelControl = new LibraryWheelControl();

						BrowseView.GridControl.cleanUI();
						BrowseView.LibraryWheelControl.activate();
						//set lastSlaveValue false to restore library default state
						BrowseView.LibraryWheelControl.lastSlaveValue = false;
						BrowseView.LibraryWheelControl.loadLibraryMenu(result);
						navigation.setFocus('selectedmaster');
                        if (BrowseView.MessagePopup) {
                            BrowseView.MessagePopup.resetFocus();
                        }
                        //self.checkUVTermsOfService();
					}
					else {
						BrowseView.hideExtras();
						$("librarytop").getElement(".buttons").removeClass("double");
						$("librarypanel").show();
						$("librarytop").show();
						
						$$(".libraryActivate").hide();
						navigation.setFocus('btnLibraryBrowseStore');
						application.currentView.layoutIsDirty = true;
						BrowseView.CurrentProcessLoaded = true;
					}
				});
			}
			$('uicontainer').addClass('redbuttons');
			
//			this.setFocus();
			
		},
		handleNavigate: function(payload){
			//This is necessary because of the dynamic nature in which buttons are displayed and hidded.
			if(BrowseView.currentState == "library-view"){
				//If user clicks left and the current element is on the browse store button (no titles loaded) first check to see if the activate button is present or else go to the library dock button.
				if(payload.args[0].direction == "left" && application.element.current == "btnLibraryBrowseStore"){
					payload.preventDefault();
					
					if(document.getElementById('btnLibraryActivate') && document.getElementById('btnLibraryActivate').style.display == 'block'){
						navigation.setFocus('btnLibraryActivate');
					}
					else {
						navigation.setFocus('dock-library');
					}
                    if (BrowseView.MessagePopup) {
                        BrowseView.MessagePopup.resetFocus();
                    }
				}
			}
		},
		hide: function(){
			this.stopRefresh();
			$("librarypanel").hide();
		},
		startRefresh: function() {
			
			if(!this._timerStarted)
			{
				log.write("**********start refresh: "+this._timerStarted);
				$clear(this._periodical); 
				this._timerStarted = true;
				this._periodical = this.refresh.periodical(this._timer * 1000)
				
			}
			
		},
		refresh: function() {
			
			if(BrowseView.currentState == "library-view") //Only continue if we are still in the library
			{
				log.write("**********refreshing library.....");
				BrowseView.Library.show();
			}
			else
			{
				BrowseView.Library.stopRefresh();
			}

		},
		stopRefresh: function() {
			log.write("**********stop refresh");
			$clear(BrowseView.Library._periodical); 
			BrowseView.Library._timerStarted = false;
		},
		loadData: function(content, columns, template) {

			this._data = [];
			//this.saveHistory();
			this._data = content;		
			this.draw();
			
		},
		onScroll: function(direction, scrollbar)
		{
			
		},
		draw: function(){
			var self = this;
			this.cleanUI();
			this.tpl.empty();
			
			this._data.each(function(item) {
				log.write(item);
				self.tpl.append(item);
			});
			this.tpl.apply();
		},
        checkUVTermsOfService: function() {
            var self = this;
            if( $cn.config.UVTOSEnabled){
                if($cn.data.UVTermsAcceptance == "accepted"){
                    return true
                } else {
                    $cn.methods.getUVTermsOfServiceAcceptance(function(res){
                        $cn.data.UVTermsAcceptance = res;
                        if(res != 'accepted'){
                            $cn.methods.getUVTermsOfService(self.showUVTermsOfService.bind(self));
                        } else if( res == "accepted"){
                            return true;
                        }
                    });
                }
            }
        }, showUVTermsOfService : function(termsOfService) {

            this.Legal = new LegalPopup('uvtermsofservice');
            var messagePath = application.resource.uv_messages.uvTermsOfService;
            this.Legal.loadData([{
                title : ($cn.data.UVTermsAcceptance == "changed" ? messagePath.ChangedMessage : messagePath.UnacceptedMessage),
                content : messagePath.Content,
                text : termsOfService,
                "OK"      : messagePath.OK,
                "Close"   : messagePath.Close,
                "AcceptAction"  : "BrowseView.Library.acceptUVTermsOfService(true)",
                "CloseAction"  : "BrowseView.Library.Legal.hide()"
            }]);
            this.layoutIsDirty = true;
            this.Legal.firstFocus = 'LegalOK';
            this.Legal.show();
            $('SplashScreen').hide();
        }, acceptUVTermsOfService: function(accept) {
            var self = this;

            $cn.methods.acceptUVTermsOfService(function(callback) {
                self.Legal.hide();
                //This is no longer valid.
                self.Legal.hide();
                $('Overlay').setStyle('background-color','transparent');
                $cn.data.UVTermsAcceptance = callback;
            });
        },
        onActivate: function(){
			BrowseView.showActivate({
				callback: function(){
					this.show();
					navigation.setFocus('dock-library');
                    if (BrowseView.MessagePopup) {
                        BrowseView.MessagePopup.resetFocus();
                    }
				}.bind(this)
			});
		},
        onRestoreState: function(payload){
			var state = payload.args[0];

			if (state.store.currentState == 'library-view' && application.element.current == 'selectedmaster') {
				state = state[this.id];
				$extend(this, state);
				if ($cn.data.AuthToken != '') {
					this.show();		
				}
			} 
		}
	},
	Library = new Class(LibraryClass);
//-----------------------------------------------------------------------------
// librarytitleview.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author tjmchattie
 */
var TitleViewControl = new Class({
	id: 'librarytitleviewcontrol',
	persist: {},
    controls:{},
    tv:false,
    episode:true,
    layoutIsDirty: true,
    tpl: null,
    initialize: function(){
    	
		application.events.subscribe(this, 'elementfocus', this.updateSeparator);

    },
	updateSeparator: function() {
		$('WheelThumb').erase('class');
		if($(application.element.current).getPosition().x > $('WheelSeparator').getPosition().x) {
			$('WheelThumb').addClass('wheel-thumb-left');
		} else {
			$('WheelThumb').addClass('wheel-thumb-right');
		}
	},
    init: function(params, direction){
		log.write('titleviewcontrol.init()');		
        var self = this;
        
        //Persist Params
        if(params) {
            this.persist = params;               
        }      
		
	},
	cleanUI: function(){
		if($('titledetailscontainer')) {
			if($('titledetailscontainer').getChildren().length > 0){
				$('titledetailscontainer').getChildren().destroy();
			}
		}
	},
	/*
	 * Load data will:
	 * 1) Set the data source for the grid view
	 * 2) Render the local controls
	 * 3) set the data for the first item.  
	 */
	loadData: function(title) {
		this.saveHistory();
		
		var template;
		this.persist.title = title;

		this.tv = title.showTitleID && title.showTitleID > 0 && title.titleID == title.showTitleID;
		this.episode = title.showTitleID && title.showTitleID > 0 && title.titleID != title.showTitleID;
		template = this.tv ? "titleview.tvtitle" : "titleview.title";
		
		
		this.tpl = new ui.template("titledetailscontainer", application.ui.loadTpl(template));
    	
    	this.tpl.compile();
    	
		this.draw();		
	},
	drawMeta: function(key){
		log.write('Getting meta for: ' + key);
		return $cn.utilities.getMeta(key, this.persist.title.metaValues);
	},
	drawStarRating: function(key, idx){
		var rating = parseFloat($cn.utilities.getMeta(key, this.persist.title.metaValues));
		var val = '';

		if(rating >= idx){
			val = 'fullstar';
		}
		else if(rating < idx && rating > (idx - 1)) {
			val = 'halfstar';
		}
		
		return val;
	},
	getTrailer: function() {
		
	},
	getPurchaseButtonText: function() {
		var retString = '',
		preorder = false,
		buy = false,
		rent = false;
		
		this.persist.title.availableProducts.each(function(item){
			switch(item.purchaseType)
			{
				case "rent":
					rent = true;
					break;
				case "buy":
					buy = true;
					break;
				case "preorder":
					preorder = true;
					break;
					
			}
		});
			if(preorder)
			{
				retString = "Pre-order";
			}
			else if (rent && buy)
			{
				retString = "Rent or Buy";
			}
			else if (rent)
			{
				retString = "Rent";
			}
			else if (buy)
			{
				retString = "Buy";
			}
		
		return retString;
	},
	getRateButtonText: function() {
		var rating = parseFloat($cn.utilities.getMeta('YourRating', this.persist.title.metaValues));
		var retString = 'Rate it';
		if(rating > 0) {
			retString = 'Change Rating';
		} 
		return retString;
	},
	displayBonusAsset: function(key){
		
		var val = 'hideextra';
		this.persist.title.bonusAssets.each(function(item){
			if(item.bonusType == key)
			{
				val = 'showextra';
			}
		});
		return val;
	},
	displayExtra: function(key, invert){
		var b = $cn.utilities.getMeta(key, this.persist.title.metaValues);
		var val = 'hideextra';
		if((b == "True" && !invert) || (b == "False" && invert)){
			val = 'showextra';
		}
		
		return val;
	},
	/* Read config values and render grid */
	draw: function(){
        var watchStatus;
		this.cleanUI();
		
		/*
		 *  1) Create elements for titles
		 *  2) Attach a focus
		 */		
		log.write(this.persist.title);
		
		this.tpl.append(this.persist.title);
		this.tpl.apply();
		
		//SHOW HIDE BITS
		if(this.episode)
		{
			$("tdbuttonEpisodes").removeClass("hideextra");
			$("tdbuttonWatchTrailer").addClass("hideextra");
		}
		
		watchStatus = $cn.utilities.getMeta("WatchStatus", this.persist.title.metaValues);
		if(watchStatus)
		{
			switch(watchStatus)
			{
				case "Available":
					$('titlemeta_duration').show();
					$('titlemeta_dateintheathers').hide();
					$('titlemeta_flixterrating').show();
					$('titlemeta_criticrating').show();
					$('ratingstar').show();
					break;
				case "ComingSoon":
					$('titlemeta_duration').hide();
					$('titlemeta_dateintheathers').show();
					$('titlemeta_flixterrating').hide();
					$('titlemeta_criticrating').hide();
					$('ratingstar').hide();
					break;
				case "InTheaters":
					$('titlemeta_duration').show();
					$('titlemeta_dateintheathers').hide();
					$('titlemeta_flixterrating').show();
					$('titlemeta_criticrating').show();
					$('ratingstar').show();
					break;
				case "Library":
					$('titlemeta_duration').show();
					$('titlemeta_dateintheathers').hide();
					$('titlemeta_flixterrating').show();
					$('titlemeta_criticrating').show();
					$('ratingstar').show();
					break;
				
			}
		}
		
		application.currentView.layoutIsDirty = true;
	},
	saveHistory: function(){},
	loadPrevious: function(){}	
});
//-----------------------------------------------------------------------------
// librarywheel.js
// Copyright (c) 2012 - 2013, Rovi Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
 
/**
 * @author atumminaro
 */
var LibraryWheelControl = new Class({
	DEBUG: false,
	Extends: WheelControl,
	Implements: WheelControl,
	id: 'LibraryWheelControl',
	currentMasterValue: 'Movies',
	currentSlaveValue: '',
	masterWheelOptionList: [],
	libraryItems : {},
	MOVIE_GENRES : ["Action", "Adventure", "Animation", "Comedy", "Drama", "Family", "Horror", "Romance", "Sci-Fi", "Thriller", "Westerns"],
	TV_GENRES : ["Action", "Adventure", "Animation and Cartoons", "Comedy", "Drama", "Family", "Food and Leisure", "Home and Garden", "Horror", "Music", "Other", "Reality and Game Shows", "Romance", "Sci-Fi", "Sports", "Thriller", "Westerns"],

	//For Determining Orders
	MasterWheel_ORDER: ["Movies", "Movie_Rentals", "HD_Movies", "HD_TV_Shows", "TV_Shows"],
	MOVIES_ORDER : ["All", "UltraViolet", "Never_Watched", "Unavailable", "Action", "Adventure", "Animation", "Comedy", "Drama", "Family", "Horror", "Romance", "Sci-Fi", "Thriller"],
	MOVIES_RENTALS_ORDER : ["All", "Never_Watched", "Unavailable", "Action", "Adventure", "Animation", "Comedy", "Drama", "Family", "Horror", "Romance", "Sci-Fi", "Thriller", "Expired", "Expiring_Soon"],
	TV_ORDER : ["All", "Never_Watched", "Unavailable", "Action", "Adventure", "Animation and Cartoons", "Comedy", "Drama", "Family", "Food and Leisure", 
									"Home and Garden", "Horror", "Music", "Other", "Reality and Game Shows", "Romance", "Sci-Fi", "Sports", "Talk and Interview", "Thriller", "Westerns"],	
	processRawData: function(response, callback) {
		var currentItem;
		this.libraryItems = {};

        this.UV = new $cn.utilities.UserUVManager();
        this.UV.checkUVAccount(function(uvProperlyLinked) {
            for (var i = 0; i < response.items.length; i++) {
            	
                var masterWheelOptions = [];
                var slaveWheelOptions = [];
                currentItem = response.items[i];
				
				if(! uvProperlyLinked && $cn.utilities.isTrue(currentItem.isPassUV)){
                	continue;
                }
				
                switch(currentItem.titleClassification) {
                    case "Movie":
                    	if (masterWheelOptions.indexOf("Movies") < 0) {
                    		masterWheelOptions.push("Movies");
                    	}
                        break;
                    case "TV_Show":
                    case "TV_Season":
                    case "TV_Episode":
                    	if (masterWheelOptions.indexOf("TV_Shows") < 0) {
                    		masterWheelOptions.push("TV_Shows");
                    	}
                        break;
                    default:
                        break;
                }
                
                if (currentItem.isHD == true && masterWheelOptions.indexOf("HD_Movies") < 0 && currentItem.titleClassification == "Movie") {
                    masterWheelOptions.push("HD_Movies");
                }

                if (currentItem.isHD == true && masterWheelOptions.indexOf("HD_TV_Shows") < 0 && currentItem.titleClassification != "Movie") {
                    masterWheelOptions.push("HD_TV_Shows");
                }
                
                if (currentItem.purchaseType == "rent") {
                	if (masterWheelOptions.indexOf("Movie_Rentals") < 0) {
                		masterWheelOptions.push("Movie_Rentals");
                	}
                    //Videos that will expire within the next 7days.
                    if (currentItem.minutesToExpire > 0 && currentItem.minutesToExpire < 7 * 24 * 60 && slaveWheelOptions.indexOf("Expiring_Soon") < 0)
                    {
                        slaveWheelOptions.push("Expiring_Soon");
                    }
                }
                
                if (uvProperlyLinked && $cn.utilities.isTrue(currentItem.isPassUV) && (-1 === $cn.utilities.inArray("UltraViolet", slaveWheelOptions))) {
                	if (slaveWheelOptions.indexOf("UltraViolet") < 0) {
                		slaveWheelOptions.push("UltraViolet");
                	}
                }
                
                var needBreak = false;
                switch(currentItem.watchStatus) {
                    case "WatchNow": {
                    	if (slaveWheelOptions.indexOf("All") < 0) {
                    		slaveWheelOptions.push("All");
                    	}
                        break;
                    }
                    case "ExpiredRental": {
                    	if (slaveWheelOptions.indexOf("All") < 0) {
                    		slaveWheelOptions.push("All");
                    	}
                    	if (slaveWheelOptions.indexOf("Expired") < 0) {
                    		slaveWheelOptions.push("Expired");
                    	}
                        break;
                    }
                    default: {
                    	if (slaveWheelOptions.indexOf("All") < 0) {
                    		slaveWheelOptions.push("All");
                    	}
                    	if (slaveWheelOptions.indexOf("Unavailable") < 0) {
                    		slaveWheelOptions.push("Unavailable");
                    	}
                        this.configObject(masterWheelOptions, slaveWheelOptions, currentItem);
                        needBreak = true;
                        break;
                	}
                }
                if (needBreak)
                    continue;
                
                if ($cn.utilities.getMeta("LicensesDelivered", currentItem.metaValues) == "0" && slaveWheelOptions.indexOf("Never_Watched") < 0) {
                    slaveWheelOptions.push("Never_Watched");
                }
                
    			if (currentItem.genres)
    			{
    				var currentGenre;
    				var targetGenres = (currentItem.titleClassification == "Movie") ? this.MOVIE_GENRES : this.TV_GENRES;
    				for (var genreIndex = 0;  genreIndex < currentItem.genres.length; genreIndex++)
    				{
    					currentGenre = currentItem.genres[genreIndex];
    					for (var targetGenreIndex = 0;  targetGenreIndex < targetGenres.length; targetGenreIndex++)
    					{
    						if (targetGenres[targetGenreIndex] == currentGenre.name && slaveWheelOptions.indexOf(currentGenre.name) < 0)
    						{
    							slaveWheelOptions.push(currentGenre.name);
    							break;
    						}
    					}
    				}
    			}
                
                this.configObject(masterWheelOptions, slaveWheelOptions, currentItem);
            }
            
            callback(this);
        }.bind(this), true);
	},
	
	configObject: function(masterWheelOptions, slaveWheelOptions, targetItem) {
		if (this.DEBUG) log.write("librarywheel.configObject Debug: Enter with " + masterWheelOptions + ", " + slaveWheelOptions + ", " + targetItem);
		for (var i = 0; i < masterWheelOptions.length; i++)
		{
			if (!this.libraryItems[masterWheelOptions[i]])
			{
				this.libraryItems[masterWheelOptions[i]] = { };
			}
			for (var j = 0; j < slaveWheelOptions.length; j++)
			{
				//Expired and  Expiring_Soon should display only under Movie_Rentals
				if (masterWheelOptions[i] == "Movie_Rentals" || (slaveWheelOptions[j] != "Expired" &&  slaveWheelOptions[j] != "Expiring_Soon")) 
				{
					if (!this.libraryItems[masterWheelOptions[i]][slaveWheelOptions[j]])
					{
						this.libraryItems[masterWheelOptions[i]][slaveWheelOptions[j]] = [];
					}
					if (this.DEBUG) log.write("librarywheel.configObject Debug: About to push targetItem " + targetItem + " into " + masterWheelOptions[i] + ", " + slaveWheelOptions[j]);
					this.libraryItems[masterWheelOptions[i]][slaveWheelOptions[j]].push(targetItem);
				}
			}
		}
	},
	
	getMasterWheelOptions : function() {
		var retArray = [];
	
		for (var i = 0; i < this.MasterWheel_ORDER.length; i++)
		{
			for (var key in this.libraryItems)
			{
				if (key == this.MasterWheel_ORDER[i]) 
				{
					retArray.push(key);
					break;
				}
			}
		}
		
		return retArray;
		
	},
	
	getSlaveWheelOptionsbyMasterWheel: function(masterWheelOption) {
		var targetArray = [];
		switch(masterWheelOption)
		{
			case "Movies":
			case "HD_Movies":
				targetArray = this.MOVIES_ORDER;
			break;
			case "Movie_Rentals":
				targetArray = this.MOVIES_RENTALS_ORDER;
			break;
			case "TV_Shows":
			case "HD_TV_Shows":
				targetArray = this.TV_ORDER;
			break;
		}
		var retArray = [];
		var sortArray = [];
		for (var key in this.libraryItems[masterWheelOption])
		{
			for (var sortIndex = 0; sortIndex < targetArray.length; sortIndex++)
			{
				if (key == targetArray[sortIndex])
				{
					sortArray[sortIndex] = true;
					break;
				}
			}
		}
		for (var i = 0; i < sortArray.length; i++)
		{
			if (sortArray[i])
			{
			    // See if there is a replacement for this string in the resource file.
			    var s = application.resource.LibSlaveWheelOptions[targetArray[i]];
			    if (!s) {
			        // Just use the name as is, but replacing "_" with a line break.
			        s = targetArray[i].replace("_", "<br/>");
			    }
				retArray.push({ name: s, iD: targetArray[i] });

			}
		}
		
		return retArray;
				
	},
	
	getContentbyWheelOptions: function(masterWheelOption, slaveWheelOption) {
		return this.libraryItems[masterWheelOption][slaveWheelOption];
	},
	
	loadLibraryMenu: function(result, masterSelection) {
		this.processRawData(result, function(){
            var options = this.getMasterWheelOptions();

            var data = [],
                selection = 0;
            if($cn.config.EnableD2D && $cn.config.DeviceD2DEnabled){
                options.push("D2D_Movies"); //push on d2d wheeloption for info
            }
            for (var i = 0; i < options.length; ++i) {
                var item = options[i];
                log.write(options[i]);

                if (item == masterSelection) {
                    selection = i;
                }
                
                data.push({
                    iD: item,
                    name: application.resource.LibMasterWheelOptions[item]
                });
            }
            
            this.currentMasterValue = options[selection];	
            this.loadData(data, {}, selection);
            this.loadSlaveDataSource(this.currentMasterValue);
            navigation.setFocus("selectedmaster");
        }.bind(this));
	},
	handleWheelItemChange: function(payload){	
		if(payload.context === ActiveWheel) {			
			var self = this,
			    p = payload.args[0],
                masterValue = p.source[p.selectedidx].parentID,
                slaveValue = p.selectedvalue;
			
			/* If the source is the master column then load the slave wheel with the child elements from the new selection */
			if(p.sourceid.indexOf('master') > -1) {
				masterValue = p.selectedvalue;
				this.currentMasterValue = p.selectedvalue;
				
				$('slavedatasource').getElements('div').destroy();
				//payload.context._renderWheel($('slavedatasource'), payload.context._slaveSource[p.selectedvalue]);
				payload.context.loadSlaveDataSource(this.currentMasterValue);
			}
			
			this.lastValue = slaveValue;
			BrowseView.CurrentWheelValue = masterValue + ":" + slaveValue;
			
			if(p.sourceid.indexOf('slave') > -1){
                masterValue = payload.context.currentMasterValue;
                this.lastSlaveValue = slaveValue;
				log.write('The slave wheel item has changed. Update results.');
                if(masterValue == "D2D_Movies" && slaveValue == "Info"){
                    var d2dData = [{'title' : application.resource.lib_d2d_info.title,
                        'step1' : application.resource.lib_d2d_info.step1,
                        'step2' : application.resource.lib_d2d_info.step2,
                        'step3' : application.resource.lib_d2d_info.step3
                    }];
                    BrowseView.LastGridProcess = "d2dinfo";
                    application.events.publish('loadgrid', {grid: 'disctodigitalgrid', gridProcess: 'd2dinfo', data: d2dData, columns: 1, template: 'disctodigitalgrid'});
                } else if(self.lastValue && (self.lastValue == masterValue || self.lastValue == slaveValue)) {
					/* Fire wheel value event */
					application.events.publish('gridloading', {grid: 'titlegrid', message: "loading", columns: 3});
					BrowseView.CurrentLibraryGenreID = this.lastValue;
					
					setTimeout(function(){
						if(self.lastValue && (self.lastValue == masterValue || self.lastValue == slaveValue)){
							self.loadSlaveGrid(p.source[p.selectedidx]);
						}
					}, 1000);
				}
			}			
		}
	},
	loadSlaveDataCallback: function(masterKey){
        this._slaveSource[masterKey] = this.getSlaveWheelOptionsbyMasterWheel(masterKey);

        var itemLength = this._slaveSource[masterKey].length;
        var lastSlaveIndex = 0;
        if(this.lastSlaveValue){
            while(itemLength--){
                if(this._slaveSource[masterKey][itemLength].iD == this.lastSlaveValue){
                    lastSlaveIndex = itemLength;
                    log.write("FOuND IT at index" + itemLength);
                }
            }
        }
        if(lastSlaveIndex === 0) {
            this.lastSlaveValue = false;
        }
        this._renderWheel($('slavedatasource'),this._slaveSource[masterKey], lastSlaveIndex);
		
		application.events.publish('gridloading', {grid: 'titlegrid', message: "loading", columns: 3});
		this.loadSlaveGrid(this._slaveSource[masterKey][lastSlaveIndex]);

	},
	loadSlaveDataSource: function(masterKey){
        var self= this,
            lastSlaveIndex = 0;
            
		BrowseView.CurrentProcessLoaded = false;
		log.write("masterKey: " + masterKey);
		this._slaveSource[masterKey] = [];

        // add info to d2d since it won't come back in the api call
        if(masterKey == "D2D_Movies"){
            this._slaveSource[masterKey].push({
                name: application.resource.LibSlaveWheelOptions.Info,
                iD: "Info"
            });
            var d2dData = [{'title' : application.resource.lib_d2d_info.title,
                'step1' : application.resource.lib_d2d_info.step1,
                'step2' : application.resource.lib_d2d_info.step2,
                'step3' : application.resource.lib_d2d_info.step3
            }];
            this._renderWheel($('slavedatasource'),this._slaveSource[masterKey], lastSlaveIndex);
            BrowseView.LastGridProcess = "d2dinfo";
            application.events.publish('loadgrid', {grid: 'disctodigitalgrid', gridProcess: 'd2dinfo', data: d2dData, columns: 1, template: 'disctodigitalgrid'});

        } else {
            self.loadSlaveDataCallback(masterKey);
        }
	},
	loadSlaveGrid: function(slaveValue){

		BrowseView.LastGridProcess = "librarylist";
		
		var items = this.getContentbyWheelOptions(this.currentMasterValue, slaveValue.iD );
		if(items.length > 0)
		{	
			//Load Grid
			application.events.publish('loadgrid', {grid: 'titlegrid', data: items, columns: 3, gridProcess: 'librarylist', template: 'librarylist', cssClass: 'library'});
		}
		else
		{
			application.events.publish('loadgrid', {grid: 'titlegrid', data: null, template: 'librarylist', gridProcess: 'librarylist', cssClass: 'library'});
		}
		BrowseView.CurrentProcessLoaded = true;
		
	}
});
